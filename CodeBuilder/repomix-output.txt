This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-24T19:18:29.263Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
Assets.xcassets/
  AppIcon.appiconset/
    Contents.json
  Logo.imageset/
    Contents.json
  Contents.json
Models/
  Problem.swift
Preview Content/
  Preview Assets.xcassets/
    Contents.json
Resources/
  problems.json
Utilities/
  BackgroundGradientModifier.swift
  ColorExtensions.swift
  MenuItem.swift
  SplashScreenView.swift
ViewModels/
  AuthViewModel.swift
  ForumViewModel.swift
  ProblemsData.swift
  UserStatsViewModel.swift
Views/
  Authentication/
    SignInView.swift
    SignUpView.swift
  Components/
    AutoScroller.swift
    CarouselCard.swift
    CodeBlockView.swift
    ProblemHeaderView.swift
    SearchBar.swift
  DailyChallenge/
    DailyChallengeView.swift
  Forum/
    ForumView.swift
    InlineReplyView.swift
    ReplyView.swift
  Home/
    ArticleDetailView.swift
    HomeView.swift
    LearningView.swift
    ResumeView.swift
  Problems/
    ProblemDetailView.swift
    ProblemsView.swift
  Search/
    SearchView.swift
  Settings/
    AccountView.swift
    AppDelegate.swift
    SettingsView.swift
CodeBuilderApp.swift
CodeBuilderRelease.entitlements
ContentView.swift
GoogleService-Info.plist
Info.plist

================================================================
Repository Files
================================================================

================
File: Assets.xcassets/AppIcon.appiconset/Contents.json
================
{"images":[{"size":"60x60","expected-size":"180","filename":"180.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"3x"},{"size":"40x40","expected-size":"80","filename":"80.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"2x"},{"size":"40x40","expected-size":"120","filename":"120.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"3x"},{"size":"60x60","expected-size":"120","filename":"120.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"2x"},{"size":"57x57","expected-size":"57","filename":"57.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"1x"},{"size":"29x29","expected-size":"58","filename":"58.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"2x"},{"size":"29x29","expected-size":"29","filename":"29.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"1x"},{"size":"29x29","expected-size":"87","filename":"87.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"3x"},{"size":"57x57","expected-size":"114","filename":"114.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"2x"},{"size":"20x20","expected-size":"40","filename":"40.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"2x"},{"size":"20x20","expected-size":"60","filename":"60.png","folder":"Assets.xcassets/AppIcon.appiconset/","idiom":"iphone","scale":"3x"},{"size":"1024x1024","filename":"1024.png","expected-size":"1024","idiom":"ios-marketing","folder":"Assets.xcassets/AppIcon.appiconset/","scale":"1x"}]}

================
File: Assets.xcassets/Logo.imageset/Contents.json
================
{
  "images" : [
    {
      "filename" : "Logo.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Assets.xcassets/Contents.json
================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Models/Problem.swift
================
//
//  Problem.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 10/17/24.
//

import Foundation

struct Problem: Identifiable, Codable {
    let id: UUID
    let title: String
    let description: String
    let difficulty: String
    let articleURL: URL
    var availableBlocks: [String] // Changed from [CodeBlock] to [String]
    let correctSolution: [String] // Changed from [CodeBlock] to [String]
}

================
File: Preview Content/Preview Assets.xcassets/Contents.json
================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Resources/problems.json
================
[
    {
        "id": "BEA9F93B-9F17-4126-B0AB-D38FAF213025",
        "title": "Print Hello World",
        "description": "Arrange the code blocks to print 'Hello World' in the console.",
        "difficulty": "Easy",
        "articleURL": "https://www.example.com/articles/hello-world",
        "availableBlocks": [
            "func greet() {",
            "print(\"Hello World\")",
            "}"
        ],
        "correctSolution": [
            "func greet() {",
            "print(\"Hello World\")",
            "}"
        ]
    },
    {
        "id": "36353321-28CF-4C21-9152-840D078D8C07",
        "title": "Calculate Sum",
        "description": "Arrange the code blocks to calculate the sum of two numbers.",
        "difficulty": "Medium",
        "articleURL": "https://www.example.com/articles/calculate-sum",
        "availableBlocks": [
            "let sum = a + b",
            "let a = 5",
            "let b = 10"
        ],
        "correctSolution": [
            "let a = 5",
            "let b = 10",
            "let sum = a + b"
        ]
    },
    {
        "id": "550e8400-e29b-41d4-a716-446655440000",
        "title": "Factorial Calculation",
        "description": "Arrange the code blocks to compute the factorial of a number using recursion.",
        "difficulty": "Hard",
        "articleURL": "https://www.example.com/articles/factorial-recursion",
        "availableBlocks": [
            "func factorial(_ n: Int) -> Int {",
            "if n == 0 {",
            "return 1",
            "}",
            "return n * factorial(n - 1)",
            "}"
        ],
        "correctSolution": [
            "func factorial(_ n: Int) -> Int {",
            "if n == 0 {",
            "return 1",
            "}",
            "return n * factorial(n - 1)",
            "}"
        ]
    },
    {
        "id": "F47AC10B-58CC-4372-A567-0E02B2C3D479",
        "title": "Reverse String",
        "description": "Arrange the code blocks to reverse a given string.",
        "difficulty": "Easy",
        "articleURL": "https://www.example.com/articles/reverse-string",
        "availableBlocks": [
            "func reverseString(_ s: String) -> String {",
            "var reversed = \"\"",
            "for char in s {",
            "reversed = String(char) + reversed",
            "}",
            "return reversed",
            "}"
        ],
        "correctSolution": [
            "func reverseString(_ s: String) -> String {",
            "var reversed = \"\"",
            "for char in s {",
            "reversed = String(char) + reversed",
            "}",
            "return reversed",
            "}"
        ]
    },
    {
        "id": "123E4567-E89B-12D3-A456-426614174000",
        "title": "Fibonacci Sequence",
        "description": "Arrange the code blocks to generate the first N Fibonacci numbers.",
        "difficulty": "Medium",
        "articleURL": "https://www.example.com/articles/fibonacci-sequence",
        "availableBlocks": [
            "func fibonacci(_ n: Int) -> [Int] {",
            "var sequence = [0, 1]",
            "for i in 2..<n {",
            "let next = sequence[i-1] + sequence[i-2]",
            "sequence.append(next)",
            "}",
            "return sequence",
            "}"
        ],
        "correctSolution": [
            "func fibonacci(_ n: Int) -> [Int] {",
            "var sequence = [0, 1]",
            "for i in 2..<n {",
            "let next = sequence[i-1] + sequence[i-2]",
            "sequence.append(next)",
            "}",
            "return sequence",
            "}"
        ]
    },
    {
        "id": "3F2504E0-4F89-11D3-9A0C-0305E82C3301",
        "title": "Palindrome Checker",
        "description": "Arrange the code blocks to check if a string is a palindrome.",
        "difficulty": "Easy",
        "articleURL": "https://www.example.com/articles/palindrome-checker",
        "availableBlocks": [
            "func isPalindrome(_ s: String) -> Bool {",
            "let cleaned = s.lowercased().filter { $0.isLetter }",
            "return cleaned == String(cleaned.reversed())",
            "}"
        ],
        "correctSolution": [
            "func isPalindrome(_ s: String) -> Bool {",
            "let cleaned = s.lowercased().filter { $0.isLetter }",
            "return cleaned == String(cleaned.reversed())",
            "}"
        ]
    },
    {
        "id": "6FA459EA-EE8A-3CA4-894E-DB77E160355E",
        "title": "Merge Sorted Arrays",
        "description": "Arrange the code blocks to merge two sorted arrays into one sorted array.",
        "difficulty": "Medium",
        "articleURL": "https://www.example.com/articles/merge-sorted-arrays",
        "availableBlocks": [
            "func mergeSortedArrays(_ a: [Int], _ b: [Int]) -> [Int] {",
            "var merged = [Int]()",
            "var i = 0, j = 0",
            "while i < a.count && j < b.count {",
            "if a[i] < b[j] {",
            "merged.append(a[i])",
            "i += 1",
            "} else {",
            "merged.append(b[j])",
            "j += 1",
            "}",
            "}",
            "while i < a.count {",
            "merged.append(a[i])",
            "i += 1",
            "}",
            "while j < b.count {",
            "merged.append(b[j])",
            "j += 1",
            "}",
            "return merged",
            "}"
        ],
        "correctSolution": [
            "func mergeSortedArrays(_ a: [Int], _ b: [Int]) -> [Int] {",
            "var merged = [Int]()",
            "var i = 0, j = 0",
            "while i < a.count && j < b.count {",
            "if a[i] < b[j] {",
            "merged.append(a[i])",
            "i += 1",
            "} else {",
            "merged.append(b[j])",
            "j += 1",
            "}",
            "}",
            "while i < a.count {",
            "merged.append(a[i])",
            "i += 1",
            "}",
            "while j < b.count {",
            "merged.append(b[j])",
            "j += 1",
            "}",
            "return merged",
            "}"
        ]
    },
    {
        "id": "C56A4180-65AA-42EC-A945-5FD21DEC0538",
        "title": "Find Maximum Element",
        "description": "Arrange the code blocks to find the maximum element in an array.",
        "difficulty": "Easy",
        "articleURL": "https://www.example.com/articles/find-maximum-element",
        "availableBlocks": [
            "func findMaximum(_ arr: [Int]) -> Int? {",
            "guard !arr.isEmpty else { return nil }",
            "var max = arr[0]",
            "for num in arr {",
            "if num > max {",
            "max = num",
            "}",
            "}",
            "return max",
            "}"
        ],
        "correctSolution": [
            "func findMaximum(_ arr: [Int]) -> Int? {",
            "guard !arr.isEmpty else { return nil }",
            "var max = arr[0]",
            "for num in arr {",
            "if num > max {",
            "max = num",
            "}",
            "}",
            "return max",
            "}"
        ]
    },
    {
        "id": "1B9D6BCD-BBFD-4B2D-9B5D-AB0C9E3B3E4C",
        "title": "Binary Search",
        "description": "Arrange the code blocks to perform binary search on a sorted array.",
        "difficulty": "Hard",
        "articleURL": "https://www.example.com/articles/binary-search",
        "availableBlocks": [
            "func binarySearch(_ arr: [Int], target: Int) -> Int? {",
            "var left = 0",
            "var right = arr.count - 1",
            "while left <= right {",
            "let mid = left + (right - left) / 2",
            "if arr[mid] == target {",
            "return mid",
            "} else if arr[mid] < target {",
            "left = mid + 1",
            "} else {",
            "right = mid - 1",
            "}",
            "}",
            "return nil",
            "}"
        ],
        "correctSolution": [
            "func binarySearch(_ arr: [Int], target: Int) -> Int? {",
            "var left = 0",
            "var right = arr.count - 1",
            "while left <= right {",
            "let mid = left + (right - left) / 2",
            "if arr[mid] == target {",
            "return mid",
            "} else if arr[mid] < target {",
            "left = mid + 1",
            "} else {",
            "right = mid - 1",
            "}",
            "}",
            "return nil",
            "}"
        ]
    },
    {
        "id": "6B29FC40-5B7E-457A-8EFA-8F1A82CA1D44",
        "title": "Count Occurrences of Element",
        "description": "Arrange the code blocks to count the number of occurrences of a specific element in an array.",
        "difficulty": "Easy",
        "articleURL": "https://www.example.com/articles/count-occurrences",
        "availableBlocks": [
            "func countOccurrences(_ arr: [Int], target: Int) -> Int {",
            "return arr.filter { $0 == target }.count",
            "}"
        ],
        "correctSolution": [
            "func countOccurrences(_ arr: [Int], target: Int) -> Int {",
            "return arr.filter { $0 == target }.count",
            "}"
        ]
    },
    {
        "id": "1B9D6BCD-BBFD-4B2D-9B5D-AB0C9E3B3E4D",
        "title": "Find Intersection of Arrays",
        "description": "Arrange the code blocks to find the intersection of two arrays.",
        "difficulty": "Medium",
        "articleURL": "https://www.example.com/articles/intersection-arrays",
        "availableBlocks": [
            "func intersection(_ a: [Int], _ b: [Int]) -> [Int] {",
            "let setA = Set(a)",
            "let setB = Set(b)",
            "let intersection = setA.intersection(setB)",
            "return Array(intersection)",
            "}"
        ],
        "correctSolution": [
            "func intersection(_ a: [Int], _ b: [Int]) -> [Int] {",
            "let setA = Set(a)",
            "let setB = Set(b)",
            "let intersection = setA.intersection(setB)",
            "return Array(intersection)",
            "}"
        ]
    },
    {
        "id": "3F2504E0-4F89-11D3-9A0C-0305E82C3302",
        "title": "Longest Substring Without Repeating Characters",
        "description": "Arrange the code blocks to find the length of the longest substring without repeating characters.",
        "difficulty": "Hard",
        "articleURL": "https://www.example.com/articles/longest-substring",
        "availableBlocks": [
            "func lengthOfLongestSubstring(_ s: String) -> Int {",
            "var charIndexMap = [Character: Int]()",
            "var maxLength = 0",
            "var start = 0",
            "for (i, char) in s.enumerated() {",
            "if let index = charIndexMap[char], index >= start {",
            "start = index + 1",
            "}",
            "charIndexMap[char] = i",
            "maxLength = max(maxLength, i - start + 1)",
            "}",
            "return maxLength",
            "}"
        ],
        "correctSolution": [
            "func lengthOfLongestSubstring(_ s: String) -> Int {",
            "var charIndexMap = [Character: Int]()",
            "var maxLength = 0",
            "var start = 0",
            "for (i, char) in s.enumerated() {",
            "if let index = charIndexMap[char], index >= start {",
            "start = index + 1",
            "}",
            "charIndexMap[char] = i",
            "maxLength = max(maxLength, i - start + 1)",
            "}",
            "return maxLength",
            "}"
        ]
    },
    {
        "id": "C56A4180-65AA-42EC-A945-5FD21DEC0539",
        "title": "Transpose Matrix",
        "description": "Arrange the code blocks to transpose a given matrix.",
        "difficulty": "Medium",
        "articleURL": "https://www.example.com/articles/transpose-matrix",
        "availableBlocks": [
            "func transpose(_ matrix: [[Int]]) -> [[Int]] {",
            "guard let firstRow = matrix.first else { return [] }",
            "var transposed = Array(repeating: Array(repeating: 0, count: matrix.count), count: firstRow.count)",
            "for (i, row) in matrix.enumerated() {",
            "for (j, val) in row.enumerated() {",
            "transposed[j][i] = val",
            "}",
            "}",
            "return transposed",
            "}"
        ],
        "correctSolution": [
            "func transpose(_ matrix: [[Int]]) -> [[Int]] {",
            "guard let firstRow = matrix.first else { return [] }",
            "var transposed = Array(repeating: Array(repeating: 0, count: matrix.count), count: firstRow.count)",
            "for (i, row) in matrix.enumerated() {",
            "for (j, val) in row.enumerated() {",
            "transposed[j][i] = val",
            "}",
            "}",
            "return transposed",
            "}"
        ]
    },
    {
        "id": "1B9D6BCD-BBFD-4B2D-9B5D-AB0C9E3B3E4E",
        "title": "Capitalize Words",
        "description": "Arrange the code blocks to capitalize the first letter of each word in a string.",
        "difficulty": "Easy",
        "articleURL": "https://www.example.com/articles/capitalize-words",
        "availableBlocks": [
            "func capitalizeWords(in s: String) -> String {",
            "return s.split(separator: \" \").map { $0.capitalized }.joined(separator: \" \")",
            "}"
        ],
        "correctSolution": [
            "func capitalizeWords(in s: String) -> String {",
            "return s.split(separator: \" \").map { $0.capitalized }.joined(separator: \" \")",
            "}"
        ]
    },
    {
        "id": "E2C3D4F5-6A7B-8901-234C-56D7E8F9A0B1",
        "title": "Remove Nth Node from End",
        "description": "Arrange the code blocks to remove the Nth node from the end of a linked list.",
        "difficulty": "Hard",
        "articleURL": "https://www.example.com/articles/remove-nth-node",
        "availableBlocks": [
            "class ListNode {",
            "var val: Int",
            "var next: ListNode?",
            "init(_ val: Int) {",
            "self.val = val",
            "self.next = nil",
            "}",
            "}",
            "func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {",
            "let dummy = ListNode(0)",
            "dummy.next = head",
            "var first: ListNode? = dummy",
            "var second: ListNode? = dummy",
            "for _ in 0..<n+1 {",
            "first = first?.next",
            "}",
            "while first != nil {",
            "first = first?.next",
            "second = second?.next",
            "}",
            "second?.next = second?.next?.next",
            "return dummy.next",
            "}"
        ],
        "correctSolution": [
            "class ListNode {",
            "var val: Int",
            "var next: ListNode?",
            "init(_ val: Int) {",
            "self.val = val",
            "self.next = nil",
            "}",
            "}",
            "func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {",
            "let dummy = ListNode(0)",
            "dummy.next = head",
            "var first: ListNode? = dummy",
            "var second: ListNode? = dummy",
            "for _ in 0..<n+1 {",
            "first = first?.next",
            "}",
            "while first != nil {",
            "first = first?.next",
            "second = second?.next",
            "}",
            "second?.next = second?.next?.next",
            "return dummy.next",
            "}"
        ]
    },
    {
        "id": "F3D4E5F6-7B8C-9012-345D-67E8F9A0B1C2",
        "title": "Bubble Sort",
        "description": "Arrange the code blocks to sort an array using Bubble Sort.",
        "difficulty": "Medium",
        "articleURL": "https://www.example.com/articles/bubble-sort",
        "availableBlocks": [
            "func bubbleSort(_ arr: inout [Int]) {",
            "let n = arr.count",
            "for i in 0..<n {",
            "for j in 0..<(n - i - 1) {",
            "if arr[j] > arr[j + 1] {",
            "arr.swapAt(j, j + 1)",
            "}",
            "}",
            "}",
            "}"
        ],
        "correctSolution": [
            "func bubbleSort(_ arr: inout [Int]) {",
            "let n = arr.count",
            "for i in 0..<n {",
            "for j in 0..<(n - i - 1) {",
            "if arr[j] > arr[j + 1] {",
            "arr.swapAt(j, j + 1)",
            "}",
            "}",
            "}",
            "}"
        ]
    },
    {
        "id": "C1A5260A-8363-4C07-A4CD-DBF9A3B5C6F4",
        "title": "Remove Whitespaces",
        "description": "Arrange the code blocks to remove all whitespaces from a string.",
        "difficulty": "Easy",
        "articleURL": "https://www.example.com/articles/remove-whitespaces",
        "availableBlocks": [
            "func removeWhitespaces(from s: String) -> String {",
            "return s.replacingOccurrences(of: \" \", with: \"\")",
            "}"
        ],
        "correctSolution": [
            "func removeWhitespaces(from s: String) -> String {",
            "return s.replacingOccurrences(of: \" \", with: \"\")",
            "}"
        ]
    },
    {
        "id": "1B9D6BCD-BBFD-4B2D-9B5D-AB0C9E3B3E4F",
        "title": "Find Second Largest Element",
        "description": "Arrange the code blocks to find the second largest element in an array.",
        "difficulty": "Medium",
        "articleURL": "https://www.example.com/articles/second-largest-element",
        "availableBlocks": [
            "func secondLargest(_ arr: [Int]) -> Int? {",
            "var first: Int? = nil",
            "var second: Int? = nil",
            "for num in arr {",
            "if first == nil || num > first! {",
            "second = first",
            "first = num",
            "} else if (second == nil || num > second!) && num != first {",
            "second = num",
            "}",
            "}",
            "return second",
            "}"
        ],
        "correctSolution": [
            "func secondLargest(_ arr: [Int]) -> Int? {",
            "var first: Int? = nil",
            "var second: Int? = nil",
            "for num in arr {",
            "if first == nil || num > first! {",
            "second = first",
            "first = num",
            "} else if (second == nil || num > second!) && num != first {",
            "second = num",
            "}",
            "}",
            "return second",
            "}"
        ]
    }
]

================
File: Utilities/BackgroundGradientModifier.swift
================
//
//  BackgroundGradientModifier.swift
//  CodeBuilder
//
//  Created by aaron perkel on 11/24/24.
//


import SwiftUI

struct BackgroundGradientModifier: ViewModifier {
    func body(content: Content) -> some View {
        content
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [Color.blue.opacity(0.2), Color.purple.opacity(0.2)]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
            )
    }
}

extension View {
    func applyBackgroundGradient() -> some View {
        self.modifier(BackgroundGradientModifier())
    }
}

================
File: Utilities/ColorExtensions.swift
================
//
//  ColorExtensions.swift
//  CodeBuilder
//
//  Created by aaron perkel on 10/27/24.
//

import SwiftUI

extension Color {
    static var cardBackground: Color {
        Color(UIColor { traitCollection in
            switch traitCollection.userInterfaceStyle {
            case .dark:
                return UIColor.secondarySystemBackground
            default:
                return UIColor.systemGray5 // Slightly darker in light mode
            }
        })
    }
}

#Preview {
    ContentView()
        .environmentObject(AuthViewModel.shared)
}

================
File: Utilities/MenuItem.swift
================
//
//  MenuItem.swift
//  CodeBuilder
//
//  Created by aaron perkel on 10/27/24.
//

import SwiftUI

struct MenuItem {
    let title: String
    let subtitle: String?
    let iconName: String
    let color: Color
    let destination: AnyView
}

================
File: Utilities/SplashScreenView.swift
================
//
//  SplashScreenView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 11/24/24.
//

import SwiftUI

struct SplashScreenView: View {
    @State private var isActive = false
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        if isActive {
            ContentView()
        } else {
            VStack {
              Image("Logo")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 200, height: 200)
                Text("CodeBuilder")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundColor(.primary)
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [Color.blue.opacity(0.2), Color.purple.opacity(0.2)]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
            )
            .onAppear {
                DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                    withAnimation {
                        self.isActive = true
                    }
                }
            }
        }
    }
}

#Preview {
  SplashScreenView()
}

================
File: ViewModels/AuthViewModel.swift
================
// AuthViewModel.swift

import Foundation
import FirebaseAuth
import Combine
import Firebase
import FirebaseFirestore

// MARK: - Firestore Field Keys

struct FirestoreKeys {
    static let email = "email"
    static let problemsSolved = "problemsSolved"
    static let streak = "streak"
    static let lastProblemSolvedDate = "lastProblemSolvedDate"
    static let solvedProblemIDs = "solvedProblemIDs"
    static let displayName = "displayName"
}

// MARK: - AuthViewModel

class AuthViewModel: ObservableObject {
    // Published properties for UI binding
    @Published var user: User?
    @Published var isSignedIn: Bool = false
    @Published var authErrorMessage: String?
    
    // Singleton instance
    static let shared = AuthViewModel()
    
    private var authStateListenerHandle: AuthStateDidChangeListenerHandle?
    
    // Private initializer to enforce singleton usage
    private init() {
        addListeners()
    }
    
    deinit {
        removeListeners()
    }
    
    // MARK: - Listener Management
    
    private func addListeners() {
        authStateListenerHandle = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
            DispatchQueue.main.async {
                self?.user = user
                self?.isSignedIn = user != nil
            }
        }
    }
    
    private func removeListeners() {
        if let handle = authStateListenerHandle {
            Auth.auth().removeStateDidChangeListener(handle)
        }
    }
    
    // MARK: - User Profile Management
    
    private func createUserProfileInFirestore() {
        guard let userID = Auth.auth().currentUser?.uid else { return }
        let db = Firestore.firestore()
        let userRef = db.collection("users").document(userID)
        
        userRef.setData([
            FirestoreKeys.email: Auth.auth().currentUser?.email ?? "",
            FirestoreKeys.problemsSolved: 0,
            FirestoreKeys.streak: 0,
            FirestoreKeys.lastProblemSolvedDate: Timestamp(date: Date())
        ], merge: true) { [weak self] error in
            if let error = error {
                print("Error adding/updating user in Firestore: \(error.localizedDescription)")
                DispatchQueue.main.async {
                    self?.authErrorMessage = "Failed to create user profile."
                }
            } else {
                print("User profile created/updated in Firestore!")
            }
        }
    }
    
    // MARK: - Authentication Methods
    
    /// Validates email format using a regular expression.
    private func isValidEmail(_ email: String) -> Bool {
        let emailRegEx = #"^[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$"#
        let emailPred = NSPredicate(format: "SELF MATCHES %@", emailRegEx)
        return emailPred.evaluate(with: email)
    }
    
    /// Validates password strength.
    private func isValidPassword(_ password: String) -> Bool {
        return password.count >= 6
    }
    
    /// Validates display name.
    private func isValidDisplayName(_ displayName: String) -> Bool {
        return !displayName.trimmingCharacters(in: .whitespaces).isEmpty
    }
    
    /// Signs in the user with email and password.
    func signIn(email: String, password: String) {
        // Input Validation
        guard isValidEmail(email) else {
            DispatchQueue.main.async {
                self.authErrorMessage = "Invalid email format."
            }
            return
        }
        
        guard isValidPassword(password) else {
            DispatchQueue.main.async {
                self.authErrorMessage = "Password must be at least 6 characters."
            }
            return
        }
        
        Auth.auth().signIn(withEmail: email, password: password) { [weak self] result, error in
            // Ensure UI updates are on the main thread
            DispatchQueue.main.async {
                if let error = error {
                    print("Sign in error: \(error.localizedDescription)")
                    self?.authErrorMessage = error.localizedDescription
                } else if let user = result?.user {
                    print("User signed in: \(user.uid)")
                    self?.user = user
                    self?.isSignedIn = true
                    self?.createUserProfileInFirestore()
                } else {
                    self?.authErrorMessage = "Unknown sign-in error."
                }
            }
        }
    }
    
    /// Signs out the current user.
    func signOut() {
        do {
            try Auth.auth().signOut()
            DispatchQueue.main.async {
                self.user = nil
                self.isSignedIn = false
                self.authErrorMessage = nil
                print("User signed out")
            }
        } catch let error {
            print("Sign out error: \(error.localizedDescription)")
            DispatchQueue.main.async {
                self.authErrorMessage = error.localizedDescription
            }
        }
    }
    
    /// Signs up a new user with email, password, and display name.
    func signUp(email: String, password: String, displayName: String) {
        // Input Validation
        guard isValidEmail(email) else {
            DispatchQueue.main.async {
                self.authErrorMessage = "Invalid email format."
            }
            return
        }
        
        guard isValidPassword(password) else {
            DispatchQueue.main.async {
                self.authErrorMessage = "Password must be at least 6 characters."
            }
            return
        }
        
        guard isValidDisplayName(displayName) else {
            DispatchQueue.main.async {
                self.authErrorMessage = "Display name cannot be empty."
            }
            return
        }
        
        Auth.auth().createUser(withEmail: email, password: password) { [weak self] result, error in
            // Ensure UI updates are on the main thread
            DispatchQueue.main.async {
                if let error = error {
                    print("Sign up error: \(error.localizedDescription)")
                    self?.authErrorMessage = error.localizedDescription
                } else if let user = result?.user {
                    let changeRequest = user.createProfileChangeRequest()
                    changeRequest.displayName = displayName
                    changeRequest.commitChanges { [weak self] error in
                        if let error = error {
                            print("Profile update error: \(error.localizedDescription)")
                            self?.authErrorMessage = error.localizedDescription
                        } else {
                            self?.user = Auth.auth().currentUser
                            self?.isSignedIn = true
                            print("User signed up and profile updated")
                            self?.createUserProfileInFirestore()
                        }
                    }
                } else {
                    self?.authErrorMessage = "Unknown sign-up error."
                }
            }
        }
    }
}

================
File: ViewModels/ForumViewModel.swift
================
//
//  ForumViewModel.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 11/17/24.
//

// ViewModels/ForumViewModel.swift

import Foundation
import FirebaseFirestore
import Combine

// MARK: - Reply Model

struct Reply: Identifiable, Codable {
    @DocumentID var id: String?
    var content: String
    var userID: String
    var displayName: String
    var timestamp: Date

    enum CodingKeys: String, CodingKey {
        case id
        case content
        case userID
        case displayName
        case timestamp
    }
}

// MARK: - Post Model

struct Post: Identifiable, Codable {
    @DocumentID var id: String?
    var title: String
    var userID: String
    var displayName: String
    var timestamp: Date

    // **Reintroduced 'replies' as an optional property**
    var replies: [Reply] = []

    // **Exclude 'replies' from CodingKeys to prevent decoding issues**
    enum CodingKeys: String, CodingKey {
        case title
        case userID
        case displayName
        case timestamp
    }

    // **Custom initializer to handle 'replies'**
    init(title: String, userID: String, displayName: String, timestamp: Date, replies: [Reply] = []) {
        self.title = title
        self.userID = userID
        self.displayName = displayName
        self.timestamp = timestamp
        self.replies = replies
    }

    // **Ensure 'replies' is not decoded from Firestore data**
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.title = try container.decode(String.self, forKey: .title)
        self.userID = try container.decode(String.self, forKey: .userID)
        self.displayName = try container.decode(String.self, forKey: .displayName)
        self.timestamp = try container.decode(Date.self, forKey: .timestamp)
        self.replies = [] // Initialize as empty; will be populated separately
    }
}

class ForumViewModel: ObservableObject {
    @Published var posts: [Post] = []
    @Published var errorMessage: String?
    
    private var db = Firestore.firestore()
    private var cancellables = Set<AnyCancellable>()
    private var replyListeners: [String: ListenerRegistration] = [:] // To manage reply listeners

    init() {
        fetchPosts()
    }
    
    deinit {
        // Remove all reply listeners when the ViewModel is deallocated
        for listener in replyListeners.values {
            listener.remove()
        }
    }

    /// Fetches posts from Firestore and sets up listeners for their replies.
    func fetchPosts() {
      db.collection("posts")
          .order(by: "timestamp", descending: true)
          .addSnapshotListener { [weak self] (querySnapshot, error) in
              guard let self = self else { return }
              if let error = error {
                  DispatchQueue.main.async {
                      self.errorMessage = "Failed to fetch posts: \(error.localizedDescription)"
                  }
                  print("Failed to fetch posts: \(error.localizedDescription)")
                  return
              }
              
              // Decode posts
              let fetchedPosts: [Post] = querySnapshot?.documents.compactMap { doc in
                  do {
                      var post = try doc.data(as: Post.self)
                      post.id = doc.documentID // Set the id manually
                      print("Fetched post: \(post.title) with ID: \(post.id ?? "No ID")")
                      return post
                  } catch {
                      print("Error decoding post: \(error.localizedDescription)")
                      return nil
                  }
              } ?? []
              
                
                print("Total fetched posts: \(fetchedPosts.count)")
                
                // Determine added and removed posts
                let existingPostIDs = Set(self.posts.compactMap { $0.id })
                let fetchedPostIDs = Set(fetchedPosts.compactMap { $0.id })
                
                let addedPosts = fetchedPosts.filter { post in
                    if let id = post.id {
                        return !existingPostIDs.contains(id)
                    }
                    return false
                }
                
                let removedPosts = self.posts.filter { post in
                    if let id = post.id {
                        return !fetchedPostIDs.contains(id)
                    }
                    return false
                }
                
                // Remove listeners for removed posts
                for post in removedPosts {
                    if let id = post.id, let listener = self.replyListeners[id] {
                        listener.remove()
                        self.replyListeners.removeValue(forKey: id)
                        print("Removed listener for post ID: \(id)")
                    }
                }
                
                // Add new posts and set up listeners for their replies
                for post in addedPosts {
                    if let id = post.id {
                        self.posts.append(post)
                        print("Added post: \(post.title) with ID: \(id)")
                        self.listenToReplies(for: post)
                    }
                }
                
                // Update existing posts if needed (e.g., title changes)
                for index in self.posts.indices {
                    if let fetchedPost = fetchedPosts.first(where: { $0.id == self.posts[index].id }) {
                        self.posts[index].title = fetchedPost.title
                        self.posts[index].userID = fetchedPost.userID
                        self.posts[index].displayName = fetchedPost.displayName
                        self.posts[index].timestamp = fetchedPost.timestamp
                        print("Updated post: \(self.posts[index].title) with ID: \(self.posts[index].id ?? "No ID")")
                    }
                }
            }
    }
    
    /// Sets up a listener for the replies subcollection of a given post.
    private func listenToReplies(for post: Post) {
        guard let postId = post.id else { return }
        
        let listener = db.collection("posts").document(postId).collection("replies")
            .order(by: "timestamp", descending: false)
            .addSnapshotListener { [weak self] (querySnapshot, error) in
                guard let self = self else { return }
                if let error = error {
                    DispatchQueue.main.async {
                        self.errorMessage = "Failed to fetch replies: \(error.localizedDescription)"
                    }
                    print("Failed to fetch replies: \(error.localizedDescription)")
                    return
                }
                
                let fetchedReplies: [Reply] = querySnapshot?.documents.compactMap { doc in
                    try? doc.data(as: Reply.self)
                } ?? []
                
                DispatchQueue.main.async {
                    if let index = self.posts.firstIndex(where: { $0.id == postId }) {
                        self.posts[index].replies = fetchedReplies
                        print("Updated replies for post ID: \(postId)")
                    }
                }
            }
        
        // Store the listener so it can be removed later
        replyListeners[postId] = listener
    }
    
    /// Adds a new post to Firestore.
    func addPost(title: String, userID: String, displayName: String) {
        let newPost = Post(title: title, userID: userID, displayName: displayName, timestamp: Date())
        
        do {
            let _ = try db.collection("posts").addDocument(from: newPost)
            print("Post added successfully.")
        } catch {
            DispatchQueue.main.async {
                self.errorMessage = "Failed to add post: \(error.localizedDescription)"
            }
            print("Error adding post: \(error.localizedDescription)")
        }
    }
    
    /// Adds a reply to an existing post.
    func addReply(to post: Post, content: String, userID: String, displayName: String) {
        guard let postId = post.id else { return }
        let newReply = Reply(content: content, userID: userID, displayName: displayName, timestamp: Date())
        
        do {
            try db.collection("posts").document(postId).collection("replies").addDocument(from: newReply)
            print("Reply added successfully.")
        } catch {
            DispatchQueue.main.async {
                self.errorMessage = "Failed to add reply: \(error.localizedDescription)"
            }
            print("Error adding reply: \(error.localizedDescription)")
        }
    }
}

================
File: ViewModels/ProblemsData.swift
================
//
//  ProblemsData.swift
//  CodeBuilder
//
//  Created by aaron perkel on 10/28/24.
//

import Foundation

class ProblemsData: ObservableObject {
    static let shared = ProblemsData()
    @Published var problems: [Problem] = []
    @Published var dailyProblem: Problem?

    private let dailyProblemKey = "DailyProblemID"
    private let dailyProblemDateKey = "DailyProblemDate"

    private init() {
        loadProblems()
        selectDailyProblem()
    }

    private func loadProblems() {
        if let url = Bundle.main.url(forResource: "problems", withExtension: "json") {
            do {
                let data = try Data(contentsOf: url)
                let decoder = JSONDecoder()
                decoder.keyDecodingStrategy = .useDefaultKeys
                problems = try decoder.decode([Problem].self, from: data)
                print("Loaded \(problems.count) problems.")
            } catch {
                print("Error loading problems: \(error)")
            }
        } else {
            print("Problems file not found.")
        }
    }

    private func selectDailyProblem() {
        let today = Calendar.current.startOfDay(for: Date())
        let storedDate = UserDefaults.standard.object(forKey: dailyProblemDateKey) as? Date ?? Date(timeIntervalSince1970: 0)

        if Calendar.current.isDate(today, inSameDayAs: storedDate),
           let problemIDString = UserDefaults.standard.string(forKey: dailyProblemKey),
           let problemID = UUID(uuidString: problemIDString),
           let problem = problems.first(where: { $0.id == problemID }) {
            // If the problem for today is already selected, use it
            dailyProblem = problem
            print("Using stored daily problem: \(problem.title)")
        } else {
            // Select a new random problem for today
            if !problems.isEmpty {
                dailyProblem = problems.randomElement()
                if let dailyProblem = dailyProblem {
                    UserDefaults.standard.set(dailyProblem.id.uuidString, forKey: dailyProblemKey)
                    UserDefaults.standard.set(today, forKey: dailyProblemDateKey)
                    print("Selected new daily problem: \(dailyProblem.title)")
                }
            }
        }
    }
}

================
File: ViewModels/UserStatsViewModel.swift
================
//
//  UserStatsViewModel.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 10/1/24.
//

import Foundation
import FirebaseAuth
import Combine
import Firebase
import FirebaseFirestore

// MARK: - UserStatsViewModel

class UserStatsViewModel: ObservableObject {
    // Published properties for UI binding
    @Published var problemsSolved: Int = 0
    @Published var streak: Int = 0
    @Published var solvedProblemIDs: [String] = []
    
    private var db = Firestore.firestore()
    
    // Computed property to get current user ID
    private var userID: String? {
        return Auth.auth().currentUser?.uid
    }
    
    // MARK: - Problem Solved Handling
    
    /// Records that a problem has been solved by the user.
    func problemSolved(problemID: UUID) {
        guard let userID = userID else {
            print("No user is signed in.")
            return
        }
        
        let userRef = db.collection("users").document(userID)
        let currentDate = Date()
        
        db.runTransaction { (transaction, errorPointer) -> Any? in
            do {
                let document = try transaction.getDocument(userRef)
                
                if let data = document.data() {
                    // Check if the problem is already solved
                    var existingSolvedProblemIDs = data[FirestoreKeys.solvedProblemIDs] as? [String] ?? []
                    if existingSolvedProblemIDs.contains(problemID.uuidString) {
                        print("Problem already solved. No increment.")
                        return nil // Do not proceed
                    }
                    
                    // Proceed to update
                    var problemsSolved = data[FirestoreKeys.problemsSolved] as? Int ?? 0
                    var streak = data[FirestoreKeys.streak] as? Int ?? 0
                    let lastSolvedTimestamp = data[FirestoreKeys.lastProblemSolvedDate] as? Timestamp
                    let lastSolvedDate = lastSolvedTimestamp?.dateValue() ?? Date(timeIntervalSince1970: 0)
                    
                    let calendar = Calendar.current
                    let daysDifference = calendar.dateComponents([.day], from: lastSolvedDate, to: currentDate).day ?? 0
                    
                    if daysDifference == 1 {
                        streak += 1
                    } else if daysDifference > 1 {
                        streak = 1
                    }
                    
                    problemsSolved += 1
                    existingSolvedProblemIDs.append(problemID.uuidString)
                    
                    // Update the document
                    transaction.updateData([
                        FirestoreKeys.problemsSolved: problemsSolved,
                        FirestoreKeys.streak: streak,
                        FirestoreKeys.lastProblemSolvedDate: Timestamp(date: currentDate),
                        FirestoreKeys.solvedProblemIDs: existingSolvedProblemIDs
                    ], forDocument: userRef)
                } else {
                    // Document does not exist, create it
                    transaction.setData([
                        FirestoreKeys.email: Auth.auth().currentUser?.email ?? "",
                        FirestoreKeys.problemsSolved: 1,
                        FirestoreKeys.streak: 1,
                        FirestoreKeys.lastProblemSolvedDate: Timestamp(date: currentDate),
                        FirestoreKeys.solvedProblemIDs: [problemID.uuidString]
                    ], forDocument: userRef)
                }
            } catch let error {
                print("Transaction failed: \(error.localizedDescription)")
                errorPointer?.pointee = error as NSError
                return nil
            }
            return nil
        } completion: { [weak self] (result, error) in
            if let error = error {
                print("Transaction failed: \(error.localizedDescription)")
                // Optionally, set an error message
            } else {
                print("Transaction completed successfully")
                DispatchQueue.main.async { [weak self] in
                    self?.fetchUserStats()
                }
            }
        }
    }
    
    // MARK: - Fetching User Statistics
    
    /// Fetches the latest user statistics from Firestore.
    func fetchUserStats() {
        guard let userID = userID else { return }
        let userRef = db.collection("users").document(userID)
        
        userRef.getDocument { [weak self] (document, error) in
            guard let self = self else { return }
            
            if let error = error {
                print("Error fetching user stats: \(error.localizedDescription)")
                // Optionally, set an error message
                return
            }
            
            guard let document = document, document.exists, let data = document.data() else {
                print("User stats not found")
                return
            }
            
            DispatchQueue.main.async {
                self.problemsSolved = data[FirestoreKeys.problemsSolved] as? Int ?? 0
                self.streak = data[FirestoreKeys.streak] as? Int ?? 0
                self.solvedProblemIDs = data[FirestoreKeys.solvedProblemIDs] as? [String] ?? []
            }
        }
    }
    
    // MARK: - Initialization
    
    init() {
        fetchUserStats()
    }
}

================
File: Views/Authentication/SignInView.swift
================
//
//  SignIn.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 10/1/24.
//

import SwiftUI
import AuthenticationServices // For SignInWithAppleButton

struct SignInView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.dismiss) var dismiss
    @Environment(\.colorScheme) var colorScheme
    @State private var email = ""
    @State private var password = ""
    @State private var showingSignUp = false
    @State private var showingAlert = false

    var body: some View {
        NavigationStack {
            VStack {
                Spacer()
                
                Text("CodeBuilder")
                    .font(.largeTitle)
                    .bold()
                    .padding(.bottom, 20)
                
                // Custom input fields
                VStack(spacing: 16) {
                    TextField("Email", text: $email)
                        .keyboardType(.emailAddress)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                        .padding()
                        .background(Color(.systemGray6))
                        .cornerRadius(10)
                        .padding(.horizontal)
                    SecureField("Password", text: $password)
                        .padding()
                        .background(Color(.systemGray6))
                        .cornerRadius(10)
                        .padding(.horizontal)
                }
                .padding(.bottom, 20)
                
                Button("Sign In") {
                    authViewModel.signIn(email: email, password: password)
                }
                .buttonStyle(.borderedProminent)
                .cornerRadius(10)
                .padding(.horizontal)
                .padding(.bottom, 10)
                
                // Improved Separator
                HStack {
                    Rectangle()
                        .frame(height: 1)
                        .foregroundColor(Color.gray.opacity(0.5))
                    Text("OR")
                        .foregroundColor(.gray)
                        .padding(.horizontal, 8)
                    Rectangle()
                        .frame(height: 1)
                        .foregroundColor(Color.gray.opacity(0.5))
                }
                .padding(.vertical, 10)
                .padding(.horizontal)
                .padding(.bottom, 10)
                
                // Social Sign-In Buttons
                VStack(spacing: 10) {
                    SignInWithAppleButton(
                        onRequest: { request in
                            // Handle request
                        },
                        onCompletion: { result in
                            // Handle completion
                        }
                    )
                    .signInWithAppleButtonStyle(
                      // TODO: this isnt working ? always stays black
                      colorScheme == .dark ? .white : .black
                    )
                    .frame(height: 52)
                    .cornerRadius(10)
                    .padding(.horizontal)
                    .padding(.bottom, 15)
                }
                .padding(.bottom, 20)
                
                Spacer()
                
                // Improved Sign Up Prompt
                HStack {
                    Text("Don't have an account?")
                        .foregroundColor(.secondary)
                  NavigationLink(destination: SignUpView().environmentObject(authViewModel)) {
                    Text("Sign Up")
                      .bold()
                  }
                }
                .padding(.bottom, 20)
                .sheet(isPresented: $showingSignUp) {
                    SignUpView()
                        .environmentObject(authViewModel)
                }
            }
            .navigationTitle("Sign In")
            .navigationBarTitleDisplayMode(.inline)
            .alert(isPresented: $showingAlert) {
                Alert(
                    title: Text("Error"),
                    message: Text(authViewModel.authErrorMessage ?? "An error occurred"),
                    dismissButton: .default(Text("OK"))
                )
            }
            .onReceive(authViewModel.$authErrorMessage) { errorMessage in
                if errorMessage != nil {
                    showingAlert = true
                }
            }
            .onReceive(authViewModel.$isSignedIn) { isSignedIn in
                if isSignedIn {
                    dismiss()
                }
            }
        }
    }
}

#Preview {
    SignInView()
        .environmentObject(AuthViewModel.shared) // Use the shared singleton instance
        .environmentObject(UserStatsViewModel()) // Provide UserStatsViewModel if needed
}

================
File: Views/Authentication/SignUpView.swift
================
//
//  SignUpView.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 10/1/24.
//

import SwiftUI

struct SignUpView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.dismiss) var dismiss
    @State private var email = ""
    @State private var password = ""
    @State private var displayName = ""
    @State private var showingAlert = false

    var body: some View {
        NavigationStack {
            VStack {
                Spacer()
                
                Text("Create Account")
                    .font(.largeTitle)
                    .bold()
                    .padding(.bottom, 20)
                
                // Custom input fields
                VStack(spacing: 16) {
                    TextField("Display Name", text: $displayName)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                        .padding()
                        .background(Color(.systemGray6))
                        .cornerRadius(10)
                        .padding(.horizontal)
                    
                    TextField("Email", text: $email)
                        .keyboardType(.emailAddress)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                        .padding()
                        .background(Color(.systemGray6))
                        .cornerRadius(10)
                        .padding(.horizontal)
                    
                    SecureField("Password", text: $password)
                        .padding()
                        .background(Color(.systemGray6))
                        .cornerRadius(10)
                        .padding(.horizontal)
                }
                .padding(.bottom, 20)
                
                Button("Sign Up") {
                    authViewModel.signUp(email: email, password: password, displayName: displayName)
                }
                .buttonStyle(.borderedProminent)
                .cornerRadius(10)
                .padding(.horizontal)
                .padding(.bottom, 10)
                
                Spacer()
            }
            .navigationTitle("Sign Up")
            .navigationBarTitleDisplayMode(.inline)
            .alert(isPresented: $showingAlert) {
                Alert(
                    title: Text("Error"),
                    message: Text(authViewModel.authErrorMessage ?? "An error occurred"),
                    dismissButton: .default(Text("OK"))
                )
            }
            .onReceive(authViewModel.$authErrorMessage) { errorMessage in
                if errorMessage != nil {
                    showingAlert = true
                }
            }
            .onReceive(authViewModel.$isSignedIn) { isSignedIn in
                if isSignedIn {
                    dismiss()
                }
            }
        }
    }
}

#Preview {
    SignUpView()
        .environmentObject(AuthViewModel.shared) // Use the shared singleton instance
        .environmentObject(UserStatsViewModel()) // Provide UserStatsViewModel if needed
}

================
File: Views/Components/AutoScroller.swift
================
import SwiftUI

// TabItem struct for AutoScroller
struct TabItem {
    let title: String
    let color: Color
    let iconName: String
    let destination: TabDestination
}

// Enum for destinations in AutoScroller
enum TabDestination: Hashable {
    case problems
    case learning
    case resumeTips
}

struct AutoScroller: View {
    let tabItems: [TabItem] = [
        TabItem(title: "Problems", color: .blue, iconName: "doc.text.fill", destination: .problems),
        TabItem(title: "Learning", color: .orange, iconName: "book.fill", destination: .learning),
        TabItem(title: "Resume Tips", color: .brown, iconName: "briefcase.fill", destination: .resumeTips)
    ]
    @Binding var path: NavigationPath
    @Environment(\.colorScheme) var colorScheme
    @State private var currentIndex: Int = 0
    @State private var offset: CGFloat = 0

    var body: some View {
      VStack(spacing: 20) {
            // Carousel
            GeometryReader { geometry in
                let cardWidth = geometry.size.width * 0.8
                let spacing: CGFloat = 16
                let totalSpacing = spacing * CGFloat(tabItems.count - 1)
                let totalWidth = CGFloat(tabItems.count) * cardWidth + totalSpacing

                // Compute xOffset separately
                let baseOffset = -CGFloat(currentIndex) * (cardWidth + spacing)
                let centeringOffset = (geometry.size.width - cardWidth) / 2
                let xOffset = baseOffset + centeringOffset + offset

                HStack(spacing: spacing) {
                    ForEach(tabItems.indices, id: \.self) { index in
                        let tabItem = tabItems[index]
                        CarouselCard(
                            tabItem: tabItem,
                            cardWidth: cardWidth,
                            path: $path
                        )
                    }
                }
                .frame(width: totalWidth, alignment: .leading)
                .offset(x: xOffset)
                .gesture(
                    DragGesture()
                        .onChanged { value in
                            offset = value.translation.width
                        }
                        .onEnded { value in
                            let threshold = geometry.size.width / 4
                            var newIndex = currentIndex

                            if -value.translation.width > threshold {
                                newIndex = min(currentIndex + 1, tabItems.count - 1)
                            } else if value.translation.width > threshold {
                                newIndex = max(currentIndex - 1, 0)
                            }

                            withAnimation(.easeOut) {
                                offset = 0
                                currentIndex = newIndex
                            }
                        }
                )
            }
            .frame(height: 175)
            .padding(.horizontal)

            // Page Indicator
            HStack(spacing: 8) {
                ForEach(tabItems.indices, id: \.self) { index in
                    Circle()
                        .fill(Color.primary.opacity(currentIndex == index ? 1 : 0.3))
                        .frame(width: 8, height: 8)
                        .onTapGesture {
                            withAnimation(.easeOut) {
                                currentIndex = index
                            }
                        }
                }
            }
            .padding(.top, 120)
        }
    }
}

#Preview {
    HomeView()
        .environmentObject(AuthViewModel.shared)
        .environmentObject(UserStatsViewModel())
        .environmentObject(ProblemsData.shared)
}

================
File: Views/Components/CarouselCard.swift
================
//
//  CarouselCard.swift
//  CodeBuilder
//
//  Created by aaron perkel on 10/27/24.
//

import SwiftUI

struct CarouselCard: View {
    let tabItem: TabItem
    let cardWidth: CGFloat
    @Binding var path: NavigationPath
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: tabItem.iconName)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(width: 65, height: 65)
                .foregroundColor(.white)
                .padding()
                .background(tabItem.color)
                .clipShape(RoundedRectangle(cornerRadius: 16))

            Text(tabItem.title)
                .font(.headline)
                .foregroundColor(.primary)
        }
        .frame(width: cardWidth - 50, height: 250)
        .padding(25)
        // Remove internal padding
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.cardBackground)
                .shadow(
                    color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.1),
                    radius: 8, x: 0, y: 4
                )
        )
        .onTapGesture {
            path.append(tabItem.destination)
        }
    }
}


// Preview
#Preview {
    // Sample data for the tabItem
    let sampleTabItem = TabItem(
        title: "Sample Title",
        color: .blue,
        iconName: "star.fill",
        destination: .problems
    )
    
    // Provide a constant binding for the path
    let samplePath = Binding.constant(NavigationPath())
    
    // Provide a sample cardWidth
    let sampleCardWidth: CGFloat = 300
    
    return CarouselCard(
        tabItem: sampleTabItem,
        cardWidth: sampleCardWidth,
        path: samplePath
    )
    .frame(height: 220)
}

================
File: Views/Components/CodeBlockView.swift
================
//
//  CodeBlockView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 10/28/24.
//

import SwiftUI

struct CodeBlockView: View {
    let code: String
    let backgroundColor: Color

    var body: some View {
        Text(code)
            .font(.system(.body, design: .monospaced))
            .foregroundColor(.primary)
            .padding()
            .background(backgroundColor)
            .cornerRadius(5)
            .overlay(
                RoundedRectangle(cornerRadius: 5)
                    .stroke(Color.gray.opacity(0.5), lineWidth: 1)
            )
            .onDrag {
                NSItemProvider(object: code as NSString)
            }
    }
}

#Preview {
    CodeBlockView(code: "print(\"Hello World\")", backgroundColor: Color.blue.opacity(0.1))
        .frame(width: 150, height: 50)
}

================
File: Views/Components/ProblemHeaderView.swift
================
//
//  ProblemHeaderView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 10/28/24.
//


import SwiftUI

struct ProblemHeaderView: View {
    let problem: Problem

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(problem.title)
                .font(.title)
                .padding(.bottom, 4)

            Text(problem.description)
                .padding(.bottom, 4)

            Text("Difficulty: \(problem.difficulty)")
                .font(.subheadline)
                .foregroundColor(.gray)
        }
        .padding(.horizontal)
    }
}

================
File: Views/Components/SearchBar.swift
================
//
//  SearchBar.swift
//  CodeBuilder
//
//  Created by aaron perkel on 9/26/24.
//

import SwiftUI

struct SearchBar: View {
  @Binding var text: String
  @State private var isEditing = false

  var body: some View {
    HStack {
      // Search field
      HStack {
        Image(systemName: "magnifyingglass")
          .foregroundColor(.gray)
          .padding(.leading, 8)

        TextField("Search Blocks", text: $text, onEditingChanged: { editing in
          withAnimation {
            self.isEditing = editing
          }
        })
        .foregroundColor(.primary)
        .autocapitalization(.none)
        .disableAutocorrection(true)

        if !text.isEmpty {
          Button(action: {
            self.text = ""
          }) {
            Image(systemName: "multiply.circle.fill")
              .foregroundColor(.gray)
          }
          .padding(.trailing, 8)
          .transition(.opacity)
        }
      }
      .padding(EdgeInsets(top: 8, leading: 0, bottom: 8, trailing: 0))
      .background(Color(.systemGray6))
      .cornerRadius(10.0)

      if isEditing {
        Button(action: {
          withAnimation {
            self.isEditing = false
            self.text = ""
            hideKeyboard()
          }
        }) {
          Text("Cancel")
        }
        .padding(.leading, 5)
        .transition(.move(edge: .trailing))
      }
    }
    .padding(.horizontal)
  }
}

#if canImport(UIKit)
extension View {
  func hideKeyboard() {
    UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
  }
}
#endif

#Preview {
  SearchBar(text: .constant(""))
}

================
File: Views/DailyChallenge/DailyChallengeView.swift
================
//
//  DailyChallengeView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 9/25/24.
//

import SwiftUI

struct DailyChallengeView: View {
    @ObservedObject var problemsData = ProblemsData.shared

    var body: some View {
        NavigationStack {
            if let dailyProblem = problemsData.dailyProblem {
                ProblemDetailView(problem: dailyProblem)
                    .navigationBarTitleDisplayMode(.large)
            } else {
                Text("No daily challenge available.")
                    .font(.headline)
                    .padding()
            }
        }
        .applyBackgroundGradient()
    }
}

#Preview {
    DailyChallengeView()
}

================
File: Views/Forum/ForumView.swift
================
// Views/Forum/ForumView.swift

import SwiftUI

struct ForumView: View {
  @EnvironmentObject var forumViewModel: ForumViewModel
  @EnvironmentObject var authViewModel: AuthViewModel
  @Environment(\.colorScheme) var colorScheme
  
  @State private var newPostTitle: String = ""
  @State private var showingPostAlert: Bool = false
  @State private var postAlertMessage: String = ""
  
  // Replace selectedPost with replyingToPostIDs
  @State private var replyingToPostIDs: Set<String> = []
  
  var body: some View {
    NavigationStack {
      VStack {
        Text("Post Questions for Other Community Members")
          .font(.title2)
          .padding(.top, 5)
          .navigationTitle("Forum")
          .navigationBarTitleDisplayMode(.large)
        
        Divider()
          .padding(.vertical, 5)
        
        // List of Posts
        List {
          ForEach(forumViewModel.posts) { post in
            VStack(alignment: .leading, spacing: 8) {
              HStack {
                Text(post.displayName)
                  .font(.subheadline)
                  .foregroundColor(.blue)
                Spacer()
                Text(post.timestamp, style: .date)
                  .font(.caption)
                  .foregroundColor(.gray)
              }
              
              Text(post.title)
                .font(.headline)
                .padding(.vertical, 2)
              
              HStack {
                Image(systemName: "bubble.left.and.bubble.right.fill")
                  .foregroundColor(.green)
                Text("\(post.replies.count) Replies")
                  .font(.caption)
                  .foregroundColor(.gray)
              }
              
              // Replies Section
              if !post.replies.isEmpty {
                ForEach(post.replies) { reply in
                  HStack(alignment: .top, spacing: 8) {
                    Image(systemName: "person.crop.circle.fill")
                      .resizable()
                      .frame(width: 24, height: 24)
                      .foregroundColor(.gray)
                    VStack(alignment: .leading) {
                      Text(reply.displayName)
                        .font(.caption)
                        .foregroundColor(.blue)
                      Text(reply.content)
                        .font(.body)
                    }
                  }
                  .padding(.leading, 16)
                }
              }
              
              // Reply Button
              if authViewModel.isSignedIn {
                Button(action: {
                  if let postID = post.id {
                    if replyingToPostIDs.contains(postID) {
                      replyingToPostIDs.remove(postID)
                    } else {
                      replyingToPostIDs.insert(postID)
                    }
                  }
                }) {
                  HStack {
                    Image(systemName: "arrowshape.turn.up.left")
                    Text("Reply")
                  }
                  .font(.caption)
                  .foregroundColor(.blue)
                }
                .padding(.top, 5)
              } else {
                Text("Sign in to reply.")
                  .font(.caption)
                  .foregroundColor(.gray)
                  .padding(.top, 5)
              }
              
              // Inline Reply Input
              if let postID = post.id, replyingToPostIDs.contains(postID) {
                InlineReplyView(post: post) {
                  replyingToPostIDs.remove(postID)
                }
                .environmentObject(forumViewModel)
                .environmentObject(authViewModel)
                .padding(.leading, 16)
              }
            }
            .padding(.vertical, 8)
          }
        }
        .listStyle(PlainListStyle())
        
        Divider()
          .padding(.vertical, 5)
        
        // New Post Section
        if authViewModel.isSignedIn {
          VStack(spacing: 10) {
            TextField("Ask a Question", text: $newPostTitle)
              .padding()
              .background(Color(.systemGray6))
              .cornerRadius(10)
              .padding(.horizontal)
            
            Button(action: {
              createNewPost()
            }) {
              Text("Create Post")
                .frame(maxWidth: .infinity)
                .padding()
                .background(Color.blue)
                .foregroundColor(.white)
                .cornerRadius(10)
            }
            .padding(.horizontal)
            .padding(.bottom, 10)
          }
        } else {
          Button(action: {
            // Prompt user to sign in
            showingPostAlert = true
            postAlertMessage = "Please sign in to create a post."
          }) {
            Text("Create Post")
              .frame(maxWidth: .infinity)
              .padding()
              .background(Color.gray)
              .foregroundColor(.white)
              .cornerRadius(10)
              .padding(.horizontal)
          }
          .padding(.bottom, 10)
        }
      }
      .alert(isPresented: $showingPostAlert) {
        Alert(
          title: Text("Error"),
          message: Text(postAlertMessage),
          dismissButton: .default(Text("OK"))
        )
      }
      .padding()
    }
    .applyBackgroundGradient()
  }
  /// Handles the creation of a new post.
  func createNewPost() {
    let trimmedTitle = newPostTitle.trimmingCharacters(in: .whitespacesAndNewlines)
    guard !trimmedTitle.isEmpty else {
      postAlertMessage = "Post title cannot be empty."
      showingPostAlert = true
      return
    }
    
    guard let currentUser = authViewModel.user else {
      postAlertMessage = "User not authenticated."
      showingPostAlert = true
      return
    }
    
    forumViewModel.addPost(title: trimmedTitle, userID: currentUser.uid, displayName: currentUser.displayName ?? "Anonymous")
    newPostTitle = ""
  }
  
  struct ForumView_Previews: PreviewProvider {
    static var previews: some View {
      ForumView()
        .environmentObject(AuthViewModel.shared)
        .environmentObject(ForumViewModel())
    }
  }
}

#Preview {
  ForumView()
    .environmentObject(AuthViewModel.shared)
    .environmentObject(UserStatsViewModel())
    .environmentObject(ProblemsData.shared)
    .environmentObject(ForumViewModel())
}

================
File: Views/Forum/InlineReplyView.swift
================
//
//  InlineReplyView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 11/24/24.
//


import SwiftUI

struct InlineReplyView: View {
    var post: Post
    var onReplySubmitted: () -> Void

    @EnvironmentObject var forumViewModel: ForumViewModel
    @EnvironmentObject var authViewModel: AuthViewModel
    @State private var replyContent: String = ""
    @State private var showingAlert: Bool = false
    @State private var alertMessage: String = ""
    @State private var alertTitle: String = ""

    var body: some View {
        VStack(spacing: 8) {
            TextField("Write a reply...", text: $replyContent)
                .textFieldStyle(RoundedBorderTextFieldStyle())

            HStack {
                Spacer()
                Button(action: {
                    submitReply()
                }) {
                    Text("Submit")
                        .font(.caption)
                        .padding(6)
                        .background(Color.blue)
                        .foregroundColor(.white)
                        .cornerRadius(8)
                }
            }
        }
        .alert(isPresented: $showingAlert) {
            Alert(
                title: Text(alertTitle),
                message: Text(alertMessage),
                dismissButton: .default(Text("OK"))
            )
        }
    }

    private func submitReply() {
        // Same validation and submission logic as before
        let trimmedReply = replyContent.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedReply.isEmpty else {
            alertTitle = "Error"
            alertMessage = "Reply content cannot be empty."
            showingAlert = true
            return
        }

        guard let currentUser = authViewModel.user else {
            alertTitle = "Error"
            alertMessage = "User not authenticated."
            showingAlert = true
            return
        }

        forumViewModel.addReply(
            to: post,
            content: trimmedReply,
            userID: currentUser.uid,
            displayName: currentUser.displayName ?? "Anonymous"
        )

        // Reset reply content and notify parent view
        replyContent = ""
        onReplySubmitted()
    }
}

================
File: Views/Forum/ReplyView.swift
================
// Views/Forum/ReplyView.swift

import SwiftUI

struct ReplyView: View {
    var post: Post
    @EnvironmentObject var forumViewModel: ForumViewModel
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.dismiss) var dismiss

    @State private var replyContent: String = ""
    @State private var showingAlert: Bool = false
    @State private var alertMessage: String = ""
    @State private var alertTitle: String = ""
    @State private var isSuccess: Bool = false

    var body: some View {
        VStack(spacing: 16) {
            Capsule()
                .frame(width: 40, height: 5)
                .foregroundColor(Color.gray.opacity(0.5))
                .padding(.top, 8)
            
            Text("Reply to: \(post.title)")
                .font(.headline)
                .padding(.horizontal)
                .multilineTextAlignment(.center)

            TextEditor(text: $replyContent)
                .frame(height: 100)
                .padding(8)
                .background(Color(.systemGray6))
                .cornerRadius(10)
                .padding(.horizontal)

            Button(action: {
                submitReply()
            }) {
                Text("Submit Reply")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.green)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            .padding(.horizontal)

            Spacer()
        }
        .padding(.bottom)
        .alert(isPresented: $showingAlert) {
            Alert(
                title: Text(alertTitle),
                message: Text(alertMessage),
                dismissButton: .default(Text("OK")) {
                    if isSuccess {
                        dismiss()
                    }
                }
            )
        }
    }
  
    /// Handles the submission of a reply.
    private func submitReply() {
        let trimmedReply = replyContent.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedReply.isEmpty else {
            alertTitle = "Error"
            alertMessage = "Reply content cannot be empty."
            isSuccess = false
            showingAlert = true
            return
        }
        
        guard let currentUser = authViewModel.user else {
            alertTitle = "Error"
            alertMessage = "User not authenticated."
            isSuccess = false
            showingAlert = true
            return
        }
        
        forumViewModel.addReply(to: post, content: trimmedReply, userID: currentUser.uid, displayName: currentUser.displayName ?? "Anonymous")
        
        // Reset reply content and show success message
        replyContent = ""
        alertTitle = "Success"
        alertMessage = "Your reply has been posted."
        isSuccess = true
        showingAlert = true
    }
}

struct ReplyView_Previews: PreviewProvider {
    static var previews: some View {
        // Mock Post for Preview
        let mockPost = Post(title: "Sample Post", userID: "user123", displayName: "John Doe", timestamp: Date())
        return ReplyView(post: mockPost)
            .environmentObject(ForumViewModel())
            .environmentObject(AuthViewModel.shared)
    }
}

================
File: Views/Home/ArticleDetailView.swift
================
//
//  ArticleDetailView.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 9/24/24.
//

import SwiftUICore
import SwiftUI

struct ArticleDetailView: View {
    let articleTitle: String

    var body: some View {
        ScrollView {
            Text(getArticleContent())
                .padding()
        }
        .navigationTitle(articleTitle)
    }

    func getArticleContent() -> String {
        switch articleTitle {
        case "Introduction to Arrays":
            return "Arrays are collections of elements..."
        case "Understanding Recursion":
            return "Recursion is a method where the solution..."
        default:
            return "Content not available."
        }
    }
}

#Preview {
  ArticleDetailView(articleTitle: "Preview")
}

================
File: Views/Home/HomeView.swift
================
import SwiftUI

struct HomeView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.colorScheme) var colorScheme
    @State private var showingSignIn = false
    @State private var path = NavigationPath()
    
    var body: some View {
        NavigationStack(path: $path) {
            ScrollView {
                VStack(spacing: 20) {
                    // Welcome Header
                    if authViewModel.isSignedIn {
                        ProfileHeaderView()
                    } else {
                        SignInPromptView(showingSignIn: $showingSignIn)
                    }
                    
                    // AutoScroller Carousel
                    AutoScroller(path: $path)
                    
                    // Additional Content
                    VStack(spacing: 16) {
                        Text("Your Progress")
                            .font(.headline)
                            .foregroundColor(.primary)
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .padding(.horizontal)
                        
                        HStack(spacing: 16) {
                            ProgressCardView(
                                title: "Problems Solved",
                                value: "42",
                                iconName: "checkmark.seal.fill",
                                iconColor: .green
                            )
                            ProgressCardView(
                                title: "Lessons Completed",
                                value: "15",
                                iconName: "book.fill",
                                iconColor: .orange
                            )
                            ProgressCardView(
                                title: "Resume Tips Read",
                                value: "5",
                                iconName: "briefcase.fill",
                                iconColor: .purple
                            )
                        }
                        .padding(.horizontal)
                    }
                }
                .sheet(isPresented: $showingSignIn) {
                    SignInView()
                        .environmentObject(authViewModel)
                }
              
            }
            .navigationDestination(for: TabDestination.self) { destination in
                switch destination {
                case .problems:
                    ProblemsView()
                case .learning:
                    LearningView()
                case .resumeTips:
                    ResumeView()
                }
            }
        }
        .applyBackgroundGradient()
    }
}

// Profile Header View
struct ProfileHeaderView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
      Spacer()
        HStack(spacing: 16) {
            Image(systemName: "person.fill")
                .resizable()
                .frame(width: 50, height: 50)
                .foregroundStyle(.blue)
          
            VStack(alignment: .leading, spacing: 4) {
                Text("Welcome, \(authViewModel.user?.displayName ?? "No Name")!")
                .font(.title2.bold())
                    .foregroundColor(.primary)
                Text("Ready to continue learning?")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            Spacer()
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.cardBackground)
                .shadow(
                    color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.1),
                    radius: 8, x: 0, y: 4
                )
        )
        .padding(.horizontal)
    }
}

// Progress Card View
struct ProgressCardView: View {
    var title: String
    var value: String
    var iconName: String
    var iconColor: Color
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: iconName)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(height: 30)
                .foregroundColor(.white)
                .padding()
                .background(iconColor)
                .clipShape(Circle())

            Text(value)
                .font(.title2.bold())
                .foregroundColor(.primary)

            Text(title)
                .font(.caption)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.cardBackground)
                .shadow(
                    color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.1),
                    radius: 8, x: 0, y: 4
                )
        )
    }
}

#Preview {
    ContentView()
        .environmentObject(AuthViewModel.shared)
        .environmentObject(UserStatsViewModel())
        .environmentObject(ProblemsData.shared)
        .environmentObject(ForumViewModel())
}

================
File: Views/Home/LearningView.swift
================
//
//  LearningView.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 9/24/24.
//

import SwiftUICore
import SwiftUI

struct LearningView: View {
    let articles = ["Introduction to Arrays", "Understanding Recursion"]

    var body: some View {
        List(articles, id: \.self) { article in
            NavigationLink(destination: ArticleDetailView(articleTitle: article)) {
                Text(article)
                    .font(.headline)
            }
        }
        .navigationTitle("Learning")
    }
}

================
File: Views/Home/ResumeView.swift
================
//
//  ResumeView.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 9/24/24.
//

import SwiftUICore
import SwiftUI

struct ResumeView: View {
    let articles = ["Introduction to Arrays", "Understanding Recursion"]

    var body: some View {
        List(articles, id: \.self) { article in
            NavigationLink(destination: ArticleDetailView(articleTitle: article)) {
                Text(article)
                    .font(.headline)
            }
        }
        .navigationTitle("Resume Tips")
    }
}

#Preview {
  ResumeView()
}

================
File: Views/Problems/ProblemDetailView.swift
================
import SwiftUI

struct ProblemDetailView: View {
    let problem: Problem
    @State private var availableBlocks: [String]
    @State private var arrangedBlocks: [String]
    @State private var isProblemSolved = false
    @EnvironmentObject var userStatsViewModel: UserStatsViewModel
    @Environment(\.openURL) var openURL
    
    // MARK: - Initialization
    init(problem: Problem) {
        self.problem = problem
        _availableBlocks = State(initialValue: problem.availableBlocks)
        _arrangedBlocks = State(initialValue: Array(repeating: "", count: problem.correctSolution.count))
    }
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 20) {
                if isProblemSolved {
                    Text("🎉 Congratulations! You've solved this problem.")
                        .font(.headline)
                        .foregroundColor(.green)
                        .padding()
                }
                
                ProblemHeaderView(problem: problem)
                
                // Search Bar for Available Blocks
                SearchBar(text: $searchText)
                    .padding(.horizontal)
                
                // Available Blocks Section with Categories
                AvailableBlocksSection(availableBlocks: $availableBlocks, searchText: $searchText)
                
                // Your Solution Section with Vertical Stack
                VStack(alignment: .leading, spacing: 10) {
                    Text("Your Solution")
                        .font(.headline)
                    
                    // Draggable List of Arranged Blocks
                    DragGestureList(arrangedBlocks: $arrangedBlocks, availableBlocks: $availableBlocks, problem: problem, isProblemSolved: $isProblemSolved, userStatsViewModel: userStatsViewModel)
                }
                .padding()
                
                // Buttons Section
                SolutionButtonsSection(checkSolution: checkSolution, resetSolution: resetSolution, openArticle: {
                    openURL(problem.articleURL)
                })
            }
            .padding()
        }
        .onAppear {
            // Check if the problem is already solved
            if userStatsViewModel.solvedProblemIDs.contains(problem.id.uuidString) {
                isProblemSolved = true
            }
        }
        .alert(isPresented: $showingAlert) {
            Alert(
                title: Text("Result"),
                message: Text(alertMessage),
                dismissButton: .default(Text("OK"))
            )
        }
    }
    
    // MARK: - Additional States
    @State private var searchText: String = ""
    @State private var showingAlert: Bool = false
    @State private var alertMessage: String = ""
    
    // MARK: - Helper Functions
    private func checkSolution() {
        var allCorrect = true
        for index in 0..<arrangedBlocks.count {
            if arrangedBlocks[index] != problem.correctSolution[index] {
                allCorrect = false
                break
            }
        }
        
        if allCorrect {
            isProblemSolved = true
            userStatsViewModel.problemSolved(problemID: problem.id)
            alertMessage = "🎉 Well done! You've solved the problem."
        } else {
            alertMessage = "❌ Some blocks are incorrect. Please try again."
        }
        
        showingAlert = true
    }
    
    private func resetSolution() {
        arrangedBlocks = Array(repeating: "", count: problem.correctSolution.count)
        availableBlocks = problem.availableBlocks
        isProblemSolved = false
    }
}

struct AvailableBlocksSection: View {
    @Binding var availableBlocks: [String]
    @Binding var searchText: String
    @State private var expandedCategories: Set<String> = ["Initialization", "Control Flow", "Functions", "Others"]
    
    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Available Blocks")
                .font(.headline)
            
            // Categorization Logic
            ForEach(["Initialization", "Control Flow", "Functions", "Others"], id: \.self) { category in
                VStack(alignment: .leading) {
                    CategoryHeader(category: category, isExpanded: expandedCategories.contains(category)) {
                        toggleCategory(category)
                    }
                    
                    if expandedCategories.contains(category) {
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 10) {
                                ForEach(filteredAvailableBlocks(for: category), id: \.self) { block in
                                    CodeBlockView(code: block, backgroundColor: Color.blue.opacity(0.1))
                                        .onTapGesture {
                                            addBlockToSolution(block)
                                        }
                                }
                            }
                        }
                        .padding(.bottom, 10)
                    }
                }
                .padding(.horizontal)
            }
        }
        .padding()
    }
    
    private func toggleCategory(_ category: String) {
        if expandedCategories.contains(category) {
            expandedCategories.remove(category)
        } else {
            expandedCategories.insert(category)
        }
    }
    
    private func categorizeBlock(_ block: String) -> String {
        // Enhanced categorization logic based on keywords
        if block.contains("func") || block.contains("let") || block.contains("var") {
            return "Initialization"
        } else if block.contains("if") || block.contains("for") || block.contains("while") || block.contains("return") {
            return "Control Flow"
        } else {
            return "Functions"
        }
    }
    
    private func filteredAvailableBlocks(for category: String) -> [String] {
        let blocksInCategory = availableBlocks.filter { categorizeBlock($0) == category }
        if searchText.isEmpty {
            return blocksInCategory
        } else {
            return blocksInCategory.filter { $0.lowercased().contains(searchText.lowercased()) }
        }
    }
    
    private func addBlockToSolution(_ block: String) {
        // Logic to add block to the first empty slot
        if let index = availableBlocks.firstIndex(of: block) {
            availableBlocks.remove(at: index)
            // This requires binding to arrangedBlocks; consider using a delegate or environment object
        }
    }
}

struct CategoryHeader: View {
    let category: String
    let isExpanded: Bool
    let toggle: () -> Void
    
    var body: some View {
        HStack {
            Text(category)
                .font(.subheadline)
                .bold()
            Spacer()
            Button(action: toggle) {
                Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                    .foregroundColor(.blue)
            }
        }
        .padding(.vertical, 5)
    }
}

struct DragGestureList: View {
    @Binding var arrangedBlocks: [String]
    @Binding var availableBlocks: [String]
    let problem: Problem
    @Binding var isProblemSolved: Bool
    @ObservedObject var userStatsViewModel: UserStatsViewModel
    
    var body: some View {
        VStack {
            ForEach(arrangedBlocks.indices, id: \.self) { index in
                if arrangedBlocks[index].isEmpty {
                    DropZoneView()
                        .onDrop(of: [.plainText], isTargeted: nil) { providers in
                            handleDrop(providers: providers, at: index)
                        }
                        .padding(.vertical, 4)
                } else {
                    CodeBlockView(code: arrangedBlocks[index], backgroundColor: Color.blue.opacity(0.2))
                        .onDrag {
                            return NSItemProvider(object: arrangedBlocks[index] as NSString)
                        }
                        .onDrop(of: [.plainText], isTargeted: nil) { providers in
                            handleDrop(providers: providers, at: index)
                        }
                        .padding(.vertical, 4)
                }
            }
        }
    }
    
    private func handleDrop(providers: [NSItemProvider], at index: Int) -> Bool {
        guard let provider = providers.first else { return false }
        provider.loadObject(ofClass: String.self) { (object, error) in
            DispatchQueue.main.async {
                if let block = object as? String {
                    // Remove block from availableBlocks
                    if let availableIndex = availableBlocks.firstIndex(of: block) {
                        availableBlocks.remove(at: availableIndex)
                    }
                    // Replace any existing block in the drop zone back to availableBlocks
                    if !arrangedBlocks[index].isEmpty {
                        availableBlocks.append(arrangedBlocks[index])
                    }
                    // Assign the new block
                    arrangedBlocks[index] = block
                }
            }
        }
        return true
    }
}

struct DropZoneView: View {
    var body: some View {
        RoundedRectangle(cornerRadius: 10)
            .stroke(Color.gray.opacity(0.5), lineWidth: 2)
            .frame(height: 50)
            .overlay(
                Text("Drop Here")
                    .foregroundColor(.gray)
            )
            .background(Color.gray.opacity(0.1))
            .cornerRadius(10)
    }
}

struct SolutionButtonsSection: View {
    let checkSolution: () -> Void
    let resetSolution: () -> Void
    let openArticle: () -> Void
    
    var body: some View {
        HStack(spacing: 20) {
            Button(action: checkSolution) {
                Text("Check Solution")
                    .font(.headline)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.accentColor)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            
            Button(action: resetSolution) {
                Text("Reset")
                    .font(.headline)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.red)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
        }
        .padding(.horizontal)
        
        Button(action: openArticle) {
            Text("Read Article 📖")
                .font(.headline)
                .padding()
                .frame(maxWidth: .infinity)
                .background(Color.green)
                .foregroundColor(.white)
                .cornerRadius(10)
        }
        .padding(.horizontal)
    }
}

struct DragGestureList_Previews: PreviewProvider {
    static var previews: some View {
        DragGestureList(
            arrangedBlocks: .constant(["func example() {", ""]),
            availableBlocks: .constant(["print(\"Sample\")", "}"]),
            problem: Problem(
                id: UUID(),
                title: "Sample Problem",
                description: "Arrange the code blocks to complete the function.",
                difficulty: "Easy",
                articleURL: URL(string: "https://www.example.com/articles/sample-problem")!,
                availableBlocks: [
                    "func example() {",
                    "print(\"Sample\")",
                    "}"
                ],
                correctSolution: [
                    "func example() {",
                    "print(\"Sample\")",
                    "}"
                ]
            ),
            isProblemSolved: .constant(false),
            userStatsViewModel: UserStatsViewModel()
        )
        .previewLayout(.sizeThatFits)
    }
}

struct DropZoneView_Previews: PreviewProvider {
    static var previews: some View {
        DropZoneView()
            .previewLayout(.sizeThatFits)
    }
}

================
File: Views/Problems/ProblemsView.swift
================
//
//  ProblemsView.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 9/24/24.
//

import SwiftUI

struct ProblemsView: View {
    @EnvironmentObject var userStatsViewModel: UserStatsViewModel
    @ObservedObject var problemsData = ProblemsData.shared

    var body: some View {
        NavigationView {
            List(problemsData.problems) { problem in
                NavigationLink(destination: ProblemDetailView(problem: problem)) {
                  VStack(alignment: .leading) {
                    HStack {
                      Text(problem.title)
                        .font(.headline)
                      if userStatsViewModel.solvedProblemIDs.contains(problem.id.uuidString) {
                        Image(systemName: "checkmark.circle.fill")
                          .foregroundColor(.green)
                      }
                    }
                    HStack {
                      Text("Difficulty:")
                        .font(.caption)
                        .padding(0)
                      
                      Text(problem.difficulty)
                      .font(.caption)
                      .padding(4)
                      .background(difficultyColor(for: problem.difficulty))
                      .foregroundColor(.white)
                      .cornerRadius(5)
                  }
                    }
                }
            }
            .navigationTitle("Problems")
        }
        .applyBackgroundGradient()
    }
}

func difficultyColor(for difficulty: String) -> Color {
    switch difficulty.lowercased() {
    case "easy":
        return .green
    case "medium":
        return .orange
    case "hard":
        return .red
    default:
        return .gray
    }
}

#Preview {
    ProblemsView()
        .environmentObject(UserStatsViewModel())
}

================
File: Views/Search/SearchView.swift
================
//
//  SearchView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 9/25/24.
//

import SwiftUI

struct SearchView: View {
  @State private var searchText = ""
  var body: some View {
    NavigationStack {
      SearchBar(text: $searchText)
      List {
        Section {
          Text("Search View")
          Text("This will include types of problems")
          Text("Imagine the spotify search page")
          Text("Blocky and pictures and stuff")
          Text("Top 150 Interview Questions")
        }
      }
      .navigationTitle("Search")
      .navigationBarTitleDisplayMode(.large)
    }
  }
}

#Preview {
  SearchView()
}

================
File: Views/Settings/AccountView.swift
================
//
//  AccountView.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 9/24/24.
//

import SwiftUI

struct AccountView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @EnvironmentObject var userStatsViewModel: UserStatsViewModel // Ensure this is present

    var body: some View {
        NavigationStack {
            VStack(spacing: 12) {
                Image(systemName: "person.fill")
                    .resizable()
                    .frame(width: 70, height: 70)
                    .foregroundStyle(.blue)
                    .padding(.top, 25)

                VStack(spacing: 2) {
                    Text(authViewModel.user?.displayName ?? "No Name")
                        .font(.system(size: 28, weight: .semibold))
                    Text(verbatim: authViewModel.user?.email ?? "No Email")
                        .font(.system(size: 18))
                        .foregroundColor(.gray)
                    
                    // Display Problems Solved
                    Text("Problems Solved: \(userStatsViewModel.problemsSolved)")
                        .font(.system(size: 18))
                        .foregroundColor(.blue)
                        .padding(.top, 5)
                }

                List {
                    Section {
                        NavigationLink(destination: Text("Personal Information")) {
                            HStack {
                                Image(systemName: "person.text.rectangle.fill")
                                    .foregroundColor(.blue)
                                Text("Personal Information")
                            }
                        }

                        NavigationLink(destination: Text("Subscription Info")) {
                            HStack {
                                Image(systemName: "plus.arrow.trianglehead.clockwise")
                                    .foregroundColor(.blue)
                                Text("Subscriptions")
                            }
                        }
                    }

                    Section {
                        Button(action: {
                            authViewModel.signOut()
                        }) {
                            Text("Sign Out")
                                .frame(maxWidth: .infinity)
                                .foregroundColor(.red)
                        }
                    }
                }
                .listStyle(InsetGroupedListStyle())
            }
            .navigationTitle("CodeBuilder Account")
            .navigationBarTitleDisplayMode(.inline)
        }
    }
}

#Preview {
    AccountView()
        .environmentObject(AuthViewModel.shared) // Use the shared singleton instance
        .environmentObject(UserStatsViewModel()) // Provide UserStatsViewModel
}

================
File: Views/Settings/AppDelegate.swift
================
//
//  AppDelegate.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 11/17/24.
//

import UIKit
import Firebase

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication,
                     didFinishLaunchingWithOptions launchOptions:
                        [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {
        FirebaseApp.configure()
        print("✅ Firebase configured successfully in AppDelegate.")
        return true
    }
}

================
File: Views/Settings/SettingsView.swift
================
// SettingsView.swift
// CodeBuilder
// Created by aaron perkel on 9/26/24.

import SwiftUI

struct SettingsView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.colorScheme) var colorScheme
    @State private var showingSignIn = false

    // Menu items for settings
    let settingsItems: [MenuItem] = [
        MenuItem(
            title: "General",
            subtitle: "Customize app settings",
            iconName: "gearshape.fill",
            color: .blue,
            destination: AnyView(Text("General Settings"))
        ),
        MenuItem(
            title: "Notifications",
            subtitle: "Manage notification preferences",
            iconName: "bell.fill",
            color: .red,
            destination: AnyView(Text("Notification Settings"))
        ),
        MenuItem(
            title: "Widgets",
            subtitle: "Configure your widgets",
            iconName: "square.grid.2x2.fill",
            color: .orange,
            destination: AnyView(Text("Widget Settings"))
        )
    ]

    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                // Profile Card
                if authViewModel.isSignedIn {
                    ProfileCardView()
                } else {
                    SignInPromptView(showingSignIn: $showingSignIn)
                }

                // Settings Options
                VStack(spacing: 16) {
                    ForEach(settingsItems, id: \.title) { item in
                        SettingsOptionView(
                            title: item.title,
                            subtitle: item.subtitle ?? "",
                            iconName: item.iconName,
                            iconColor: item.color,
                            destination: item.destination
                        )
                    }
                }
                .padding(.horizontal)
                .padding(.top, 10)

                Spacer()
            }
            .navigationTitle("Settings")
            .navigationBarTitleDisplayMode(.large)
            .sheet(isPresented: $showingSignIn) {
                SignInView()
                    .environmentObject(authViewModel)
            }
            .applyBackgroundGradient()
        }
    }
}

struct ProfileCardView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        NavigationLink(destination: AccountView()) {
            HStack(spacing: 16) {
                Image(systemName: "person.fill")
                    .resizable()
                    .frame(width: 50, height: 50)
                    .foregroundStyle(.blue)

                // User Info
                VStack(alignment: .leading, spacing: 4) {
                    Text(authViewModel.user?.displayName ?? "No Name")
                        .font(.title2.bold())
                        .foregroundColor(.primary)
                    Text("Account, CodeBuilder+, and more")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                Spacer()
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color(UIColor.secondarySystemBackground))
                    .shadow(
                        color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.1),
                        radius: 8, x: 0, y: 4
                    )
            )
            .padding(.horizontal)
        }
    }
}

struct SignInPromptView: View {
    @Binding var showingSignIn: Bool
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        Button(action: {
            showingSignIn = true
        }) {
            HStack(spacing: 16) {
                // Sign-In Icon
                Image(systemName: "person.badge.plus.fill")
                    .resizable()
                    .frame(width: 60, height: 60)
                    .foregroundColor(.green)

                // Sign-In Info
                VStack(alignment: .leading, spacing: 4) {
                    Text("Sign In")
                        .font(.title2.bold())
                        .foregroundColor(.primary)
                    Text("Access your account and more")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                Spacer()
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color(UIColor.secondarySystemBackground))
                    .shadow(
                        color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.1),
                        radius: 8, x: 0, y: 4
                    )
            )
            .padding(.horizontal)
        }
    }
}

struct SettingsOptionView: View {
    var title: String
    var subtitle: String
    var iconName: String
    var iconColor: Color
    var destination: AnyView
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        NavigationLink(destination: destination) {
            HStack(spacing: 16) {
                // Icon
                Image(systemName: iconName)
                    .font(.system(size: 24))
                    .foregroundColor(.white)
                    .frame(width: 60, height: 60)
                    .background(iconColor)
                    .clipShape(RoundedRectangle(cornerRadius: 12))

                // Text
                VStack(alignment: .leading, spacing: 4) {
                    Text(title)
                        .font(.headline)
                        .foregroundColor(.primary)
                    Text(subtitle)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                Spacer()
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color(UIColor.secondarySystemBackground))
                    .shadow(
                        color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.1),
                        radius: 8, x: 0, y: 4
                    )
            )
        }
    }
}

#Preview {
    SettingsView()
        .environmentObject(AuthViewModel.shared)
        .environmentObject(UserStatsViewModel())
}

================
File: CodeBuilderApp.swift
================
// CodeBuilderApp.swift
import SwiftUI
import Firebase

@main
struct CodeBuilderApp: App {
    // Integrate AppDelegate
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    @StateObject var authViewModel = AuthViewModel.shared
    @StateObject var userStatsViewModel = UserStatsViewModel()
    @StateObject var problemsData = ProblemsData.shared
    @StateObject var forumViewModel = ForumViewModel()

    var body: some Scene {
      WindowGroup {
        SplashScreenView()
            .environmentObject(authViewModel)
            .environmentObject(userStatsViewModel)
            .environmentObject(problemsData)
            .environmentObject(forumViewModel)
        
        }
      }
}

#Preview {
  SplashScreenView()
        .environmentObject(AuthViewModel.shared)
        .environmentObject(UserStatsViewModel())
        .environmentObject(ProblemsData.shared)
        .environmentObject(ForumViewModel())
}

================
File: CodeBuilderRelease.entitlements
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.developer.applesignin</key>
	<array>
		<string>Default</string>
	</array>
</dict>
</plist>

================
File: ContentView.swift
================
// ContentView.swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        TabView {
            HomeView()
              .tabItem {
                  Label("Home", systemImage: "house.fill")
              }
            ProblemsView()
              .tabItem {
                  Label("Problems", systemImage: "list.number")
              }
            DailyChallengeView()
              .tabItem {
                  Label("Daily Challenge", systemImage: "star.fill")
              }
            ForumView()
              .tabItem {
                Label("Forum", systemImage: "paperplane.fill")
            }
            SettingsView()
              .tabItem {
                  Label("Settings", systemImage: "gearshape.fill")
              }
        }
    }
}

#Preview {
    ContentView()
        .environmentObject(AuthViewModel.shared)
        .environmentObject(UserStatsViewModel())
        .environmentObject(ProblemsData.shared)
        .environmentObject(ForumViewModel())
}

================
File: GoogleService-Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CLIENT_ID</key>
	<string>583365327881-gn5rj3gan9bcju1iltibdab3jne5iad8.apps.googleusercontent.com</string>
	<key>REVERSED_CLIENT_ID</key>
	<string>com.googleusercontent.apps.583365327881-gn5rj3gan9bcju1iltibdab3jne5iad8</string>
	<key>API_KEY</key>
	<string>AIzaSyB632tVyVpRZu8bYfe_Yz0zkQxp0v3_tJc</string>
	<key>GCM_SENDER_ID</key>
	<string>583365327881</string>
	<key>PLIST_VERSION</key>
	<string>1</string>
	<key>BUNDLE_ID</key>
	<string>com.example.mgohacki.aperkel.CodeBuilder</string>
	<key>PROJECT_ID</key>
	<string>code-builder-c0acb</string>
	<key>STORAGE_BUCKET</key>
	<string>code-builder-c0acb.appspot.com</string>
	<key>IS_ADS_ENABLED</key>
	<false></false>
	<key>IS_ANALYTICS_ENABLED</key>
	<false></false>
	<key>IS_APPINVITE_ENABLED</key>
	<true></true>
	<key>IS_GCM_ENABLED</key>
	<true></true>
	<key>IS_SIGNIN_ENABLED</key>
	<true></true>
	<key>GOOGLE_APP_ID</key>
	<string>1:583365327881:ios:7a594fcb68cff8996e4cd8</string>
</dict>
</plist>

================
File: Info.plist
================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>UIAppFonts</key>
	<array>
		<string>Domine-Regular.ttf</string>
	</array>
	<key>NSAppTransportSecurity</key>
	<dict>
		<key>NSAllowsArbitraryLoads</key>
		<true/>
	</dict>
</dict>
</plist>
