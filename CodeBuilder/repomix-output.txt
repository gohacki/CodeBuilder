This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-26T01:58:22.624Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
Assets.xcassets/
  AppIcon.appiconset/
    Contents.json
  Logo.imageset/
    Contents.json
  Contents.json
Models/
  Problem.swift
Preview Content/
  Preview Assets.xcassets/
    Contents.json
Utilities/
  BackgroundGradientModifier.swift
  ColorExtensions.swift
  MenuItem.swift
  SplashScreenView.swift
ViewModels/
  AuthViewModel.swift
  ForumViewModel.swift
  ProblemsData.swift
  UserStatsViewModel.swift
Views/
  Authentication/
    SignInView.swift
    SignUpView.swift
  Components/
    AutoScroller.swift
    CarouselCard.swift
    CodeBlockView.swift
    ProblemHeaderView.swift
    SearchBar.swift
  DailyChallenge/
    DailyChallengeView.swift
  Forum/
    ForumView.swift
    InlineReplyView.swift
    PostView.swift
    ReplyView.swift
  Home/
    Articles/
      ArithmeticOperations.md
      ArrayManipulations.md
      HelloWorld.md
      IntroductionToArrays.md
      LinkedListManipulations.md
      SearchingAndSorting.md
      SlidingWindow.md
      StringManipulations.md
      UnderstandingRecursion.md
    ArticleDetailView.swift
    HomeView.swift
    LearningView.swift
    ResumeView.swift
  Problems/
    ProblemDetailView.swift
    ProblemsView.swift
  Search/
    SearchView.swift
  Settings/
    AccountView.swift
    AppDelegate.swift
    SettingsView.swift
CodeBuilderApp.swift
ContentView.swift

================================================================
Repository Files
================================================================

================
File: Assets.xcassets/AppIcon.appiconset/Contents.json
================
{
  "images" : [
    {
      "filename" : "40.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "filename" : "60.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "filename" : "29.png",
      "idiom" : "iphone",
      "scale" : "1x",
      "size" : "29x29"
    },
    {
      "filename" : "58.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "filename" : "87.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "filename" : "80.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "filename" : "120.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "filename" : "57.png",
      "idiom" : "iphone",
      "scale" : "1x",
      "size" : "57x57"
    },
    {
      "filename" : "114.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "57x57"
    },
    {
      "filename" : "120.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "filename" : "180.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "filename" : "appstore.png",
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Assets.xcassets/Logo.imageset/Contents.json
================
{
  "images" : [
    {
      "filename" : "appstore.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Assets.xcassets/Contents.json
================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Models/Problem.swift
================
//
//  Problem.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 10/17/24.
//

import Foundation

struct Problem: Identifiable, Codable {
    let id: UUID
    let title: String
    let description: String
    let difficulty: String
    let articleTitle: String
    var availableBlocks: [String] // Changed from [CodeBlock] to [String]
    let correctSolution: [String] // Changed from [CodeBlock] to [String]
}

================
File: Preview Content/Preview Assets.xcassets/Contents.json
================
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

================
File: Utilities/BackgroundGradientModifier.swift
================
//
//  BackgroundGradientModifier.swift
//  CodeBuilder
//
//  Created by aaron perkel on 11/24/24.
//


import SwiftUI

struct BackgroundGradientModifier: ViewModifier {
    func body(content: Content) -> some View {
        content
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [Color.blue.opacity(0.2), Color.purple.opacity(0.2)]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
            )
    }
}

extension View {
    func applyBackgroundGradient() -> some View {
        self.modifier(BackgroundGradientModifier())
    }
}

================
File: Utilities/ColorExtensions.swift
================
//
//  ColorExtensions.swift
//  CodeBuilder
//
//  Created by aaron perkel on 10/27/24.
//

import SwiftUI

extension Color {
    static var cardBackground: Color {
        Color(UIColor { traitCollection in
            switch traitCollection.userInterfaceStyle {
            case .dark:
                return UIColor.secondarySystemBackground
            default:
                return UIColor.systemGray5 // Slightly darker in light mode
            }
        })
    }
}

#Preview {
    ContentView()
        .environmentObject(AuthViewModel.shared)
}

================
File: Utilities/MenuItem.swift
================
//
//  MenuItem.swift
//  CodeBuilder
//
//  Created by aaron perkel on 10/27/24.
//

import SwiftUI

struct MenuItem {
    let title: String
    let subtitle: String?
    let iconName: String
    let color: Color
    let destination: AnyView
}

================
File: Utilities/SplashScreenView.swift
================
//
//  SplashScreenView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 11/24/24.
//

import SwiftUI

struct SplashScreenView: View {
    @State private var isActive = false
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        if isActive {
            ContentView()
        } else {
            VStack {
              Image("Logo")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 200, height: 200)
                    .cornerRadius(40)
                Text("CodeBuilder")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundColor(.primary)
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [Color.blue.opacity(0.2), Color.purple.opacity(0.2)]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
            )
            .onAppear {
                DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                    withAnimation {
                        self.isActive = true
                    }
                }
            }
        }
    }
}

#Preview {
  SplashScreenView()
}

================
File: ViewModels/AuthViewModel.swift
================
// AuthViewModel.swift

import Foundation
import FirebaseAuth
import Combine
import Firebase
import FirebaseFirestore

// MARK: - Firestore Field Keys

struct FirestoreKeys {
    static let email = "email"
    static let problemsSolved = "problemsSolved"
    static let streak = "streak"
    static let lastProblemSolvedDate = "lastProblemSolvedDate"
    static let solvedProblemIDs = "solvedProblemIDs"
    static let displayName = "displayName"
}

// MARK: - AuthViewModel

class AuthViewModel: ObservableObject {
    // Published properties for UI binding
    @Published var user: User?
    @Published var isSignedIn: Bool = false
    @Published var authErrorMessage: String?
    
    // Singleton instance
    static let shared = AuthViewModel()
    
    private var authStateListenerHandle: AuthStateDidChangeListenerHandle?
    
    // Private initializer to enforce singleton usage
    private init() {
        addListeners()
    }
    
    deinit {
        removeListeners()
    }
    
    // MARK: - Listener Management
    
    private func addListeners() {
        authStateListenerHandle = Auth.auth().addStateDidChangeListener { [weak self] auth, user in
            DispatchQueue.main.async {
                self?.user = user
                self?.isSignedIn = user != nil
            }
        }
    }
    
    private func removeListeners() {
        if let handle = authStateListenerHandle {
            Auth.auth().removeStateDidChangeListener(handle)
        }
    }
    
    // MARK: - User Profile Management
    
    private func createUserProfileInFirestore() {
        guard let userID = Auth.auth().currentUser?.uid else { return }
        let db = Firestore.firestore()
        let userRef = db.collection("users").document(userID)
        
        userRef.setData([
            FirestoreKeys.email: Auth.auth().currentUser?.email ?? "",
            FirestoreKeys.problemsSolved: 0,
            FirestoreKeys.streak: 0,
            FirestoreKeys.lastProblemSolvedDate: Timestamp(date: Date())
        ], merge: true) { [weak self] error in
            if let error = error {
                print("Error adding/updating user in Firestore: \(error.localizedDescription)")
                DispatchQueue.main.async {
                    self?.authErrorMessage = "Failed to create user profile."
                }
            } else {
                print("User profile created/updated in Firestore!")
            }
        }
    }
    
    // MARK: - Authentication Methods
    
    /// Validates email format using a regular expression.
    private func isValidEmail(_ email: String) -> Bool {
        let emailRegEx = #"^[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$"#
        let emailPred = NSPredicate(format: "SELF MATCHES %@", emailRegEx)
        return emailPred.evaluate(with: email)
    }
    
    /// Validates password strength.
    private func isValidPassword(_ password: String) -> Bool {
        return password.count >= 6
    }
    
    /// Validates display name.
    private func isValidDisplayName(_ displayName: String) -> Bool {
        return !displayName.trimmingCharacters(in: .whitespaces).isEmpty
    }
    
    /// Signs in the user with email and password.
    func signIn(email: String, password: String) {
        // Input Validation
        guard isValidEmail(email) else {
            DispatchQueue.main.async {
                self.authErrorMessage = "Invalid email format."
            }
            return
        }
        
        guard isValidPassword(password) else {
            DispatchQueue.main.async {
                self.authErrorMessage = "Password must be at least 6 characters."
            }
            return
        }
        
        Auth.auth().signIn(withEmail: email, password: password) { [weak self] result, error in
            // Ensure UI updates are on the main thread
            DispatchQueue.main.async {
                if let error = error {
                    print("Sign in error: \(error.localizedDescription)")
                    self?.authErrorMessage = error.localizedDescription
                } else if let user = result?.user {
                    print("User signed in: \(user.uid)")
                    self?.user = user
                    self?.isSignedIn = true
                    self?.createUserProfileInFirestore()
                } else {
                    self?.authErrorMessage = "Unknown sign-in error."
                }
            }
        }
    }
    
    /// Signs out the current user.
    func signOut() {
        do {
            try Auth.auth().signOut()
            DispatchQueue.main.async {
                self.user = nil
                self.isSignedIn = false
                self.authErrorMessage = nil
                print("User signed out")
            }
        } catch let error {
            print("Sign out error: \(error.localizedDescription)")
            DispatchQueue.main.async {
                self.authErrorMessage = error.localizedDescription
            }
        }
    }
    
    /// Signs up a new user with email, password, and display name.
    func signUp(email: String, password: String, displayName: String) {
        // Input Validation
        guard isValidEmail(email) else {
            DispatchQueue.main.async {
                self.authErrorMessage = "Invalid email format."
            }
            return
        }
        
        guard isValidPassword(password) else {
            DispatchQueue.main.async {
                self.authErrorMessage = "Password must be at least 6 characters."
            }
            return
        }
        
        guard isValidDisplayName(displayName) else {
            DispatchQueue.main.async {
                self.authErrorMessage = "Display name cannot be empty."
            }
            return
        }
        
        Auth.auth().createUser(withEmail: email, password: password) { [weak self] result, error in
            // Ensure UI updates are on the main thread
            DispatchQueue.main.async {
                if let error = error {
                    print("Sign up error: \(error.localizedDescription)")
                    self?.authErrorMessage = error.localizedDescription
                } else if let user = result?.user {
                    let changeRequest = user.createProfileChangeRequest()
                    changeRequest.displayName = displayName
                    changeRequest.commitChanges { [weak self] error in
                        if let error = error {
                            print("Profile update error: \(error.localizedDescription)")
                            self?.authErrorMessage = error.localizedDescription
                        } else {
                            self?.user = Auth.auth().currentUser
                            self?.isSignedIn = true
                            print("User signed up and profile updated")
                            self?.createUserProfileInFirestore()
                        }
                    }
                } else {
                    self?.authErrorMessage = "Unknown sign-up error."
                }
            }
        }
    }
}

================
File: ViewModels/ForumViewModel.swift
================
//
//  ForumViewModel.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 11/17/24.
//

// ViewModels/ForumViewModel.swift

import Foundation
import FirebaseFirestore
import Combine

// MARK: - Reply Model

struct Reply: Identifiable, Codable {
    @DocumentID var id: String?
    var content: String
    var userID: String
    var displayName: String
    var timestamp: Date

    enum CodingKeys: String, CodingKey {
        case id
        case content
        case userID
        case displayName
        case timestamp
    }
}

// MARK: - Post Model

struct Post: Identifiable, Codable {
    @DocumentID var id: String?
    var title: String
    var userID: String
    var displayName: String
    var timestamp: Date

    // **Reintroduced 'replies' as an optional property**
    var replies: [Reply] = []

    // **Exclude 'replies' from CodingKeys to prevent decoding issues**
    enum CodingKeys: String, CodingKey {
        case title
        case userID
        case displayName
        case timestamp
    }

    // **Custom initializer to handle 'replies'**
    init(title: String, userID: String, displayName: String, timestamp: Date, replies: [Reply] = []) {
        self.title = title
        self.userID = userID
        self.displayName = displayName
        self.timestamp = timestamp
        self.replies = replies
    }

    // **Ensure 'replies' is not decoded from Firestore data**
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.title = try container.decode(String.self, forKey: .title)
        self.userID = try container.decode(String.self, forKey: .userID)
        self.displayName = try container.decode(String.self, forKey: .displayName)
        self.timestamp = try container.decode(Date.self, forKey: .timestamp)
        self.replies = [] // Initialize as empty; will be populated separately
    }
}

class ForumViewModel: ObservableObject {
    @Published var posts: [Post] = []
    @Published var errorMessage: String?
    
    private var db = Firestore.firestore()
    private var cancellables = Set<AnyCancellable>()
    private var replyListeners: [String: ListenerRegistration] = [:] // To manage reply listeners

    init() {
        fetchPosts()
    }
    
    deinit {
        // Remove all reply listeners when the ViewModel is deallocated
        for listener in replyListeners.values {
            listener.remove()
        }
    }

    /// Fetches posts from Firestore and sets up listeners for their replies.
    func fetchPosts() {
      db.collection("posts")
          .order(by: "timestamp", descending: true)
          .addSnapshotListener { [weak self] (querySnapshot, error) in
              guard let self = self else { return }
              if let error = error {
                  DispatchQueue.main.async {
                      self.errorMessage = "Failed to fetch posts: \(error.localizedDescription)"
                  }
                  print("Failed to fetch posts: \(error.localizedDescription)")
                  return
              }
              
              // Decode posts
              let fetchedPosts: [Post] = querySnapshot?.documents.compactMap { doc in
                  do {
                      var post = try doc.data(as: Post.self)
                      post.id = doc.documentID // Set the id manually
                      print("Fetched post: \(post.title) with ID: \(post.id ?? "No ID")")
                      return post
                  } catch {
                      print("Error decoding post: \(error.localizedDescription)")
                      return nil
                  }
              } ?? []
              
                
                print("Total fetched posts: \(fetchedPosts.count)")
                
                // Determine added and removed posts
                let existingPostIDs = Set(self.posts.compactMap { $0.id })
                let fetchedPostIDs = Set(fetchedPosts.compactMap { $0.id })
                
                let addedPosts = fetchedPosts.filter { post in
                    if let id = post.id {
                        return !existingPostIDs.contains(id)
                    }
                    return false
                }
                
                let removedPosts = self.posts.filter { post in
                    if let id = post.id {
                        return !fetchedPostIDs.contains(id)
                    }
                    return false
                }
                
                // Remove listeners for removed posts
                for post in removedPosts {
                    if let id = post.id, let listener = self.replyListeners[id] {
                        listener.remove()
                        self.replyListeners.removeValue(forKey: id)
                        print("Removed listener for post ID: \(id)")
                    }
                }
                
                // Add new posts and set up listeners for their replies
                for post in addedPosts {
                    if let id = post.id {
                        self.posts.append(post)
                        print("Added post: \(post.title) with ID: \(id)")
                        self.listenToReplies(for: post)
                    }
                }
                
                // Update existing posts if needed (e.g., title changes)
                for index in self.posts.indices {
                    if let fetchedPost = fetchedPosts.first(where: { $0.id == self.posts[index].id }) {
                        self.posts[index].title = fetchedPost.title
                        self.posts[index].userID = fetchedPost.userID
                        self.posts[index].displayName = fetchedPost.displayName
                        self.posts[index].timestamp = fetchedPost.timestamp
                        print("Updated post: \(self.posts[index].title) with ID: \(self.posts[index].id ?? "No ID")")
                    }
                }
            }
    }
    
    /// Sets up a listener for the replies subcollection of a given post.
    private func listenToReplies(for post: Post) {
        guard let postId = post.id else { return }
        
        let listener = db.collection("posts").document(postId).collection("replies")
            .order(by: "timestamp", descending: false)
            .addSnapshotListener { [weak self] (querySnapshot, error) in
                guard let self = self else { return }
                if let error = error {
                    DispatchQueue.main.async {
                        self.errorMessage = "Failed to fetch replies: \(error.localizedDescription)"
                    }
                    print("Failed to fetch replies: \(error.localizedDescription)")
                    return
                }
                
                let fetchedReplies: [Reply] = querySnapshot?.documents.compactMap { doc in
                    try? doc.data(as: Reply.self)
                } ?? []
                
                DispatchQueue.main.async {
                    if let index = self.posts.firstIndex(where: { $0.id == postId }) {
                        self.posts[index].replies = fetchedReplies
                        print("Updated replies for post ID: \(postId)")
                    }
                }
            }
        
        // Store the listener so it can be removed later
        replyListeners[postId] = listener
    }
    
    /// Adds a new post to Firestore.
    func addPost(title: String, userID: String, displayName: String) {
        let newPost = Post(title: title, userID: userID, displayName: displayName, timestamp: Date())
        
        do {
            let _ = try db.collection("posts").addDocument(from: newPost)
            print("Post added successfully.")
        } catch {
            DispatchQueue.main.async {
                self.errorMessage = "Failed to add post: \(error.localizedDescription)"
            }
            print("Error adding post: \(error.localizedDescription)")
        }
    }
    
    /// Adds a reply to an existing post.
    func addReply(to post: Post, content: String, userID: String, displayName: String) {
        guard let postId = post.id else { return }
        let newReply = Reply(content: content, userID: userID, displayName: displayName, timestamp: Date())
        
        do {
            try db.collection("posts").document(postId).collection("replies").addDocument(from: newReply)
            print("Reply added successfully.")
        } catch {
            DispatchQueue.main.async {
                self.errorMessage = "Failed to add reply: \(error.localizedDescription)"
            }
            print("Error adding reply: \(error.localizedDescription)")
        }
    }
}

================
File: ViewModels/ProblemsData.swift
================
//
//  ProblemsData.swift
//  CodeBuilder
//
//  Created by aaron perkel on 10/28/24.
//

import Foundation

class ProblemsData: ObservableObject {
    static let shared = ProblemsData()
    @Published var problems: [Problem] = []
    @Published var dailyProblem: Problem?

    private let dailyProblemKey = "DailyProblemID"
    private let dailyProblemDateKey = "DailyProblemDate"

    private init() {
        loadProblems()
        selectDailyProblem()
    }

    private func loadProblems() {
        if let url = Bundle.main.url(forResource: "problems", withExtension: "json") {
            do {
                let data = try Data(contentsOf: url)
                let decoder = JSONDecoder()
                decoder.keyDecodingStrategy = .useDefaultKeys
                problems = try decoder.decode([Problem].self, from: data)
                print("Loaded \(problems.count) problems.")
            } catch {
                print("Error loading problems: \(error)")
            }
        } else {
            print("Problems file not found.")
        }
    }

    private func selectDailyProblem() {
        let today = Calendar.current.startOfDay(for: Date())
        let storedDate = UserDefaults.standard.object(forKey: dailyProblemDateKey) as? Date ?? Date(timeIntervalSince1970: 0)

        if Calendar.current.isDate(today, inSameDayAs: storedDate),
           let problemIDString = UserDefaults.standard.string(forKey: dailyProblemKey),
           let problemID = UUID(uuidString: problemIDString),
           let problem = problems.first(where: { $0.id == problemID }) {
            // If the problem for today is already selected, use it
            dailyProblem = problem
            print("Using stored daily problem: \(problem.title)")
        } else {
            // Select a new random problem for today
            if !problems.isEmpty {
                dailyProblem = problems.randomElement()
                if let dailyProblem = dailyProblem {
                    UserDefaults.standard.set(dailyProblem.id.uuidString, forKey: dailyProblemKey)
                    UserDefaults.standard.set(today, forKey: dailyProblemDateKey)
                    print("Selected new daily problem: \(dailyProblem.title)")
                }
            }
        }
    }
}

================
File: ViewModels/UserStatsViewModel.swift
================
//
//  UserStatsViewModel.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 10/1/24.
//

import Foundation
import FirebaseAuth
import Combine
import Firebase
import FirebaseFirestore

// MARK: - UserStatsViewModel

class UserStatsViewModel: ObservableObject {
    // Published properties for UI binding
    @Published var problemsSolved: Int = 0
    @Published var streak: Int = 0
    @Published var solvedProblemIDs: [String] = []
    
    private var db = Firestore.firestore()
    
    // Computed property to get current user ID
    private var userID: String? {
        return Auth.auth().currentUser?.uid
    }
    
    // MARK: - Problem Solved Handling
    
    /// Records that a problem has been solved by the user.
    func problemSolved(problemID: UUID) {
        guard let userID = userID else {
            print("No user is signed in.")
            return
        }
        
        let userRef = db.collection("users").document(userID)
        let currentDate = Date()
        
        db.runTransaction { (transaction, errorPointer) -> Any? in
            do {
                let document = try transaction.getDocument(userRef)
                
                if let data = document.data() {
                    // Check if the problem is already solved
                    var existingSolvedProblemIDs = data[FirestoreKeys.solvedProblemIDs] as? [String] ?? []
                    if existingSolvedProblemIDs.contains(problemID.uuidString) {
                        print("Problem already solved. No increment.")
                        return nil // Do not proceed
                    }
                    
                    // Proceed to update
                    var problemsSolved = data[FirestoreKeys.problemsSolved] as? Int ?? 0
                    var streak = data[FirestoreKeys.streak] as? Int ?? 0
                    let lastSolvedTimestamp = data[FirestoreKeys.lastProblemSolvedDate] as? Timestamp
                    let lastSolvedDate = lastSolvedTimestamp?.dateValue() ?? Date(timeIntervalSince1970: 0)
                    
                    let calendar = Calendar.current
                    let daysDifference = calendar.dateComponents([.day], from: lastSolvedDate, to: currentDate).day ?? 0
                    
                    if daysDifference == 1 {
                        streak += 1
                    } else if daysDifference > 1 {
                        streak = 1
                    }
                    
                    problemsSolved += 1
                    existingSolvedProblemIDs.append(problemID.uuidString)
                    
                    // Update the document
                    transaction.updateData([
                        FirestoreKeys.problemsSolved: problemsSolved,
                        FirestoreKeys.streak: streak,
                        FirestoreKeys.lastProblemSolvedDate: Timestamp(date: currentDate),
                        FirestoreKeys.solvedProblemIDs: existingSolvedProblemIDs
                    ], forDocument: userRef)
                } else {
                    // Document does not exist, create it
                    transaction.setData([
                        FirestoreKeys.email: Auth.auth().currentUser?.email ?? "",
                        FirestoreKeys.problemsSolved: 1,
                        FirestoreKeys.streak: 1,
                        FirestoreKeys.lastProblemSolvedDate: Timestamp(date: currentDate),
                        FirestoreKeys.solvedProblemIDs: [problemID.uuidString]
                    ], forDocument: userRef)
                }
            } catch let error {
                print("Transaction failed: \(error.localizedDescription)")
                errorPointer?.pointee = error as NSError
                return nil
            }
            return nil
        } completion: { [weak self] (result, error) in
            if let error = error {
                print("Transaction failed: \(error.localizedDescription)")
                // Optionally, set an error message
            } else {
                print("Transaction completed successfully")
                DispatchQueue.main.async { [weak self] in
                    self?.fetchUserStats()
                }
            }
        }
    }
    
    // MARK: - Fetching User Statistics
    
    /// Fetches the latest user statistics from Firestore.
    func fetchUserStats() {
        guard let userID = userID else { return }
        let userRef = db.collection("users").document(userID)
        
        userRef.getDocument { [weak self] (document, error) in
            guard let self = self else { return }
            
            if let error = error {
                print("Error fetching user stats: \(error.localizedDescription)")
                // Optionally, set an error message
                return
            }
            
            guard let document = document, document.exists, let data = document.data() else {
                print("User stats not found")
                return
            }
            
            DispatchQueue.main.async {
                self.problemsSolved = data[FirestoreKeys.problemsSolved] as? Int ?? 0
                self.streak = data[FirestoreKeys.streak] as? Int ?? 0
                self.solvedProblemIDs = data[FirestoreKeys.solvedProblemIDs] as? [String] ?? []
            }
        }
    }
    
    // MARK: - Initialization
    
    init() {
        fetchUserStats()
    }
}

================
File: Views/Authentication/SignInView.swift
================
//
//  SignIn.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 10/1/24.
//

import SwiftUI
import AuthenticationServices // For SignInWithAppleButton

struct SignInView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.dismiss) var dismiss
    @Environment(\.colorScheme) var colorScheme
    @State private var email = ""
    @State private var password = ""
    @State private var showingSignUp = false
    @State private var showingAlert = false

    var body: some View {
        NavigationStack {
            VStack {
                Spacer()
              
              Image("Logo")
                .resizable()
                .scaledToFit()
                .frame(width: 150, height: 150)
                .cornerRadius(40)
                
                Text("CodeBuilder")
                    .font(.largeTitle)
                    .bold()
                    .padding(.bottom, 20)
                
                // Custom input fields
                VStack(spacing: 16) {
                    TextField("Email", text: $email)
                        .keyboardType(.emailAddress)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                        .padding()
                        .background(.quinary)
                        .cornerRadius(10)
                        .padding(.horizontal)
                    SecureField("Password", text: $password)
                        .padding()
                        .background(.quinary)
                        .cornerRadius(10)
                        .padding(.horizontal)
                }
                .padding(.bottom, 20)
                
                Button("Sign In") {
                    authViewModel.signIn(email: email, password: password)
                }
                .buttonStyle(.borderedProminent)
                .cornerRadius(10)
                .padding(.horizontal)
                .padding(.bottom, 10)
                
                // Improved Separator
                HStack {
                    Rectangle()
                        .frame(height: 1)
                        .foregroundColor(Color.gray.opacity(0.5))
                    Text("OR")
                        .foregroundColor(.gray)
                        .padding(.horizontal, 8)
                    Rectangle()
                        .frame(height: 1)
                        .foregroundColor(Color.gray.opacity(0.5))
                }
                .padding(.vertical, 10)
                .padding(.horizontal)
                .padding(.bottom, 10)
                
                // Social Sign-In Buttons
                VStack(spacing: 10) {
                    SignInWithAppleButton(
                        onRequest: { request in
                            // Handle request
                        },
                        onCompletion: { result in
                            // Handle completion
                        }
                    )
                    .signInWithAppleButtonStyle(
                      colorScheme == .dark ? .white : .black
                    )
                    .frame(height: 52)
                    .cornerRadius(10)
                    .padding(.horizontal)
                    .padding(.bottom, 15)
                }
                .padding(.bottom, 20)
                
                Spacer()
                
                // Improved Sign Up Prompt
                HStack {
                    Text("Don't have an account?")
                        .foregroundColor(.secondary)
                  NavigationLink(destination: SignUpView().environmentObject(authViewModel)) {
                    Text("Sign Up")
                      .bold()
                  }
                }
                .padding(.bottom, 20)
                .sheet(isPresented: $showingSignUp) {
                    SignUpView()
                        .environmentObject(authViewModel)
                }
            }
            .navigationTitle("Sign In")
            .navigationBarTitleDisplayMode(.inline)
            .alert(isPresented: $showingAlert) {
                Alert(
                    title: Text("Error"),
                    message: Text(authViewModel.authErrorMessage ?? "An error occurred"),
                    dismissButton: .default(Text("OK"))
                )
            }
            .onReceive(authViewModel.$authErrorMessage) { errorMessage in
                if errorMessage != nil {
                    showingAlert = true
                }
            }
            .onReceive(authViewModel.$isSignedIn) { isSignedIn in
                if isSignedIn {
                    dismiss()
                }
            }
        }
    }
}

#Preview {
    SignInView()
        .environmentObject(AuthViewModel.shared) // Use the shared singleton instance
        .environmentObject(UserStatsViewModel()) // Provide UserStatsViewModel if needed
}

================
File: Views/Authentication/SignUpView.swift
================
//
//  SignUpView.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 10/1/24.
//

import SwiftUI

struct SignUpView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.dismiss) var dismiss
    @State private var email = ""
    @State private var password = ""
    @State private var displayName = ""
    @State private var showingAlert = false

    var body: some View {
        NavigationStack {
            VStack {
                Spacer()
              
              Image("Logo")
                .resizable()
                .scaledToFit()
                .frame(width: 150, height: 150)
                .cornerRadius(40)
              
                Text("Create Account")
                    .font(.largeTitle)
                    .bold()
                    .padding(.bottom, 20)
                
                // Custom input fields
                VStack(spacing: 16) {
                    TextField("Display Name", text: $displayName)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                        .padding()
                        .background(.quinary)
                        .cornerRadius(10)
                        .padding(.horizontal)
                    
                    TextField("Email", text: $email)
                        .keyboardType(.emailAddress)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                        .padding()
                        .background(.quinary)
                        .cornerRadius(10)
                        .padding(.horizontal)
                    
                    SecureField("Password", text: $password)
                        .padding()
                        .background(.quinary)
                        .cornerRadius(10)
                        .padding(.horizontal)
                }
                .padding(.bottom, 20)
            
                
                Button("Sign Up") {
                    authViewModel.signUp(email: email, password: password, displayName: displayName)
                }
                .buttonStyle(.borderedProminent)
                .cornerRadius(10)
                .padding(.horizontal)
                .padding(.bottom, 10)
                
                Spacer()
            }
            .navigationTitle("Sign Up")
            .navigationBarTitleDisplayMode(.inline)
            .alert(isPresented: $showingAlert) {
                Alert(
                    title: Text("Error"),
                    message: Text(authViewModel.authErrorMessage ?? "An error occurred"),
                    dismissButton: .default(Text("OK"))
                )
            }
            .onReceive(authViewModel.$authErrorMessage) { errorMessage in
                if errorMessage != nil {
                    showingAlert = true
                }
            }
            .onReceive(authViewModel.$isSignedIn) { isSignedIn in
                if isSignedIn {
                    dismiss()
                }
            }
        }
    }
}

#Preview {
    SignUpView()
        .environmentObject(AuthViewModel.shared) // Use the shared singleton instance
        .environmentObject(UserStatsViewModel()) // Provide UserStatsViewModel if needed
}

================
File: Views/Components/AutoScroller.swift
================
import SwiftUI

// TabItem struct for AutoScroller
struct TabItem {
    let title: String
    let color: Color
    let iconName: String
    let destination: TabDestination
}

// Enum for destinations in AutoScroller
enum TabDestination: Hashable {
    case problems
    case learning
    case resumeTips
}

struct AutoScroller: View {
    let tabItems: [TabItem] = [
        TabItem(title: "Problems", color: .blue, iconName: "doc.text.fill", destination: .problems),
        TabItem(title: "Learning", color: .orange, iconName: "book.fill", destination: .learning),
        TabItem(title: "Resume Tips", color: .brown, iconName: "briefcase.fill", destination: .resumeTips)
    ]
    @Binding var path: NavigationPath
    @Environment(\.colorScheme) var colorScheme
    @State private var currentIndex: Int = 0
    @State private var offset: CGFloat = 0

    var body: some View {
      VStack(spacing: 20) {
            // Carousel
            GeometryReader { geometry in
                let cardWidth = geometry.size.width * 0.8
                let spacing: CGFloat = 16
                let totalSpacing = spacing * CGFloat(tabItems.count - 1)
                let totalWidth = CGFloat(tabItems.count) * cardWidth + totalSpacing

                // Compute xOffset separately
                let baseOffset = -CGFloat(currentIndex) * (cardWidth + spacing)
                let centeringOffset = (geometry.size.width - cardWidth) / 2
                let xOffset = baseOffset + centeringOffset + offset

                HStack(spacing: spacing) {
                    ForEach(tabItems.indices, id: \.self) { index in
                        let tabItem = tabItems[index]
                        CarouselCard(
                            tabItem: tabItem,
                            cardWidth: cardWidth,
                            path: $path
                        )
                    }
                }
                .frame(width: totalWidth, alignment: .leading)
                .offset(x: xOffset)
                .gesture(
                    DragGesture()
                        .onChanged { value in
                            offset = value.translation.width
                        }
                        .onEnded { value in
                            let threshold = geometry.size.width / 4
                            var newIndex = currentIndex

                            if -value.translation.width > threshold {
                                newIndex = min(currentIndex + 1, tabItems.count - 1)
                            } else if value.translation.width > threshold {
                                newIndex = max(currentIndex - 1, 0)
                            }

                            withAnimation(.easeOut) {
                                offset = 0
                                currentIndex = newIndex
                            }
                        }
                )
            }
            .frame(height: 175)
            .padding(.horizontal)

            // Page Indicator
            HStack(spacing: 8) {
                ForEach(tabItems.indices, id: \.self) { index in
                    Circle()
                        .fill(Color.primary.opacity(currentIndex == index ? 1 : 0.3))
                        .frame(width: 8, height: 8)
                        .onTapGesture {
                            withAnimation(.easeOut) {
                                currentIndex = index
                            }
                        }
                }
            }
            .padding(.top, 120)
        }
    }
}

#Preview {
    HomeView()
        .environmentObject(AuthViewModel.shared)
        .environmentObject(UserStatsViewModel())
        .environmentObject(ProblemsData.shared)
}

================
File: Views/Components/CarouselCard.swift
================
//
//  CarouselCard.swift
//  CodeBuilder
//
//  Created by aaron perkel on 10/27/24.
//

import SwiftUI

struct CarouselCard: View {
    let tabItem: TabItem
    let cardWidth: CGFloat
    @Binding var path: NavigationPath
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: tabItem.iconName)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(width: 65, height: 65)
                .foregroundColor(.white)
                .padding()
                .background(tabItem.color)
                .clipShape(RoundedRectangle(cornerRadius: 16))

            Text(tabItem.title)
                .font(.headline)
                .foregroundColor(.primary)
        }
        .frame(width: cardWidth - 50, height: 250)
        .padding(25)
        // Remove internal padding
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.cardBackground)
                .shadow(
                    color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.1),
                    radius: 8, x: 0, y: 4
                )
        )
        .onTapGesture {
            path.append(tabItem.destination)
        }
    }
}


// Preview
#Preview {
    // Sample data for the tabItem
    let sampleTabItem = TabItem(
        title: "Sample Title",
        color: .blue,
        iconName: "star.fill",
        destination: .problems
    )
    
    // Provide a constant binding for the path
    let samplePath = Binding.constant(NavigationPath())
    
    // Provide a sample cardWidth
    let sampleCardWidth: CGFloat = 300
    
    return CarouselCard(
        tabItem: sampleTabItem,
        cardWidth: sampleCardWidth,
        path: samplePath
    )
    .frame(height: 220)
}

================
File: Views/Components/CodeBlockView.swift
================
//
//  CodeBlockView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 10/28/24.
//

import SwiftUI

struct CodeBlockView: View {
    let code: String
    let backgroundColor: Color

    var body: some View {
        Text(code)
            .font(.system(.body, design: .monospaced))
            .foregroundColor(.primary)
            .padding()
            .background(backgroundColor)
            .cornerRadius(5)
            .overlay(
                RoundedRectangle(cornerRadius: 5)
                    .stroke(Color.gray.opacity(0.5), lineWidth: 1)
            )
            .onDrag {
                NSItemProvider(object: code as NSString)
            }
    }
}

#Preview {
    CodeBlockView(code: "print(\"Hello World\")", backgroundColor: Color.blue.opacity(0.1))
        .frame(width: 150, height: 50)
}

================
File: Views/Components/ProblemHeaderView.swift
================
//
//  ProblemHeaderView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 10/28/24.
//


import SwiftUI

struct ProblemHeaderView: View {
    let problem: Problem

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(problem.title)
                .font(.title)
                .padding(.bottom, 4)

            Text(problem.description)
                .padding(.bottom, 4)

            Text("Difficulty: \(problem.difficulty)")
                .font(.subheadline)
                .foregroundColor(.gray)
        }
        .padding(.horizontal)
    }
}

================
File: Views/Components/SearchBar.swift
================
//
//  SearchBar.swift
//  CodeBuilder
//
//  Created by aaron perkel on 9/26/24.
//

import SwiftUI

struct SearchBar: View {
  @Binding var text: String
  @State private var isEditing = false

  var body: some View {
    HStack {
      // Search field
      HStack {
        Image(systemName: "magnifyingglass")
          .foregroundColor(.gray)
          .padding(.leading, 8)

        TextField("Search Blocks", text: $text, onEditingChanged: { editing in
          withAnimation {
            self.isEditing = editing
          }
        })
        .foregroundColor(.primary)
        .autocapitalization(.none)
        .disableAutocorrection(true)

        if !text.isEmpty {
          Button(action: {
            self.text = ""
          }) {
            Image(systemName: "multiply.circle.fill")
              .foregroundColor(.gray)
          }
          .padding(.trailing, 8)
          .transition(.opacity)
        }
      }
      .padding(EdgeInsets(top: 8, leading: 0, bottom: 8, trailing: 0))
      .background(Color(.systemGray6))
      .cornerRadius(10.0)

      if isEditing {
        Button(action: {
          withAnimation {
            self.isEditing = false
            self.text = ""
            hideKeyboard()
          }
        }) {
          Text("Cancel")
        }
        .padding(.leading, 5)
        .transition(.move(edge: .trailing))
      }
    }
    .padding(.horizontal)
  }
}

#if canImport(UIKit)
extension View {
  func hideKeyboard() {
    UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
  }
}
#endif

#Preview {
  SearchBar(text: .constant(""))
}

================
File: Views/DailyChallenge/DailyChallengeView.swift
================
//
//  DailyChallengeView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 9/25/24.
//

import SwiftUI

struct DailyChallengeView: View {
    @ObservedObject var problemsData = ProblemsData.shared

    var body: some View {
        NavigationStack {
            if let dailyProblem = problemsData.dailyProblem {
                ProblemDetailView(problem: dailyProblem)
                    .navigationBarTitleDisplayMode(.large)
            } else {
                Text("No daily challenge available.")
                    .font(.headline)
                    .padding()
            }
        }
        .applyBackgroundGradient()
    }
}

#Preview {
    DailyChallengeView()
}

================
File: Views/Forum/ForumView.swift
================
// Views/Forum/ForumView.swift

import SwiftUI

struct ForumView: View {
  @EnvironmentObject var forumViewModel: ForumViewModel
  @EnvironmentObject var authViewModel: AuthViewModel
  @Environment(\.colorScheme) var colorScheme
  
  @State private var newPostTitle: String = ""
  @State private var showingPostAlert: Bool = false
  @State private var postAlertMessage: String = ""
  
  // Replace selectedPost with replyingToPostIDs
  @State private var replyingToPostIDs: Set<String> = []
  
  var body: some View {
    NavigationStack {
      VStack {
        Divider()
          .padding(.vertical, 5)
          .font(.title2)
          .padding(.top, 5)
          .navigationTitle("Forum")
          .navigationBarTitleDisplayMode(.large)
        
        
        // List of Posts
        List {
            ForEach(forumViewModel.posts) { post in
                PostView(post: post)
                    .environmentObject(forumViewModel)
                    .environmentObject(authViewModel)
                    .listRowInsets(EdgeInsets())
            }
        }
        .listStyle(PlainListStyle())
        
        Divider()
          .padding(.vertical, 5)
        
        // New Post Section
        if authViewModel.isSignedIn {
          VStack(spacing: 10) {
            TextField("Ask a Question", text: $newPostTitle)
              .padding()
              .background(Color(.systemGray6))
              .cornerRadius(10)
              .padding(.horizontal)
            
            Button(action: {
              createNewPost()
            }) {
              Text("Create Post")
                .frame(maxWidth: .infinity)
                .padding()
                .background(Color.blue)
                .foregroundColor(.white)
                .cornerRadius(10)
            }
            .padding(.horizontal)
            .padding(.bottom, 10)
          }
        } else {
          Button(action: {
            // Prompt user to sign in
            showingPostAlert = true
            postAlertMessage = "Please sign in to create a post."
          }) {
            Text("Create Post")
              .frame(maxWidth: .infinity)
              .padding()
              .background(Color.gray)
              .foregroundColor(.white)
              .cornerRadius(10)
              .padding(.horizontal)
          }
          .padding(.bottom, 10)
        }
      }
      .alert(isPresented: $showingPostAlert) {
        Alert(
          title: Text("Error"),
          message: Text(postAlertMessage),
          dismissButton: .default(Text("OK"))
        )
      }
      .padding()
    }
    .applyBackgroundGradient()
  }
  /// Handles the creation of a new post.
  func createNewPost() {
    let trimmedTitle = newPostTitle.trimmingCharacters(in: .whitespacesAndNewlines)
    guard !trimmedTitle.isEmpty else {
      postAlertMessage = "Post title cannot be empty."
      showingPostAlert = true
      return
    }
    
    guard let currentUser = authViewModel.user else {
      postAlertMessage = "User not authenticated."
      showingPostAlert = true
      return
    }
    
    forumViewModel.addPost(title: trimmedTitle, userID: currentUser.uid, displayName: currentUser.displayName ?? "Anonymous")
    newPostTitle = ""
  }
  
  struct ForumView_Previews: PreviewProvider {
    static var previews: some View {
      ForumView()
        .environmentObject(AuthViewModel.shared)
        .environmentObject(ForumViewModel())
    }
  }
}

#Preview {
  ForumView()
    .environmentObject(AuthViewModel.shared)
    .environmentObject(UserStatsViewModel())
    .environmentObject(ProblemsData.shared)
    .environmentObject(ForumViewModel())
}

================
File: Views/Forum/InlineReplyView.swift
================
//
//  InlineReplyView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 11/24/24.
//


import SwiftUI

struct InlineReplyView: View {
    var post: Post
    var onReplySubmitted: () -> Void

    @EnvironmentObject var forumViewModel: ForumViewModel
    @EnvironmentObject var authViewModel: AuthViewModel
    @State private var replyContent: String = ""
    @State private var showingAlert: Bool = false
    @State private var alertMessage: String = ""
    @State private var alertTitle: String = ""

  var body: some View {
          VStack(spacing: 8) {
              TextField("Write a reply...", text: $replyContent)
                  .padding(8)
                  .background(.quinary)
                  .cornerRadius(8)

              HStack {
                  Spacer()
                  Button(action: {
                      submitReply()
                  }) {
                      Text("Submit")
                          .font(.subheadline)
                          .padding(8)
                          .background(Color.blue)
                          .foregroundColor(.white)
                          .cornerRadius(8)
                  }
              }
          }
          .padding(.horizontal)
      }

    private func submitReply() {
        // Same validation and submission logic as before
        let trimmedReply = replyContent.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedReply.isEmpty else {
            alertTitle = "Error"
            alertMessage = "Reply content cannot be empty."
            showingAlert = true
            return
        }

        guard let currentUser = authViewModel.user else {
            alertTitle = "Error"
            alertMessage = "User not authenticated."
            showingAlert = true
            return
        }

        forumViewModel.addReply(
            to: post,
            content: trimmedReply,
            userID: currentUser.uid,
            displayName: currentUser.displayName ?? "Anonymous"
        )

        // Reset reply content and notify parent view
        replyContent = ""
        onReplySubmitted()
    }
}

================
File: Views/Forum/PostView.swift
================
//
//  PostView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 11/25/24.
//


import SwiftUI

struct PostView: View {
    var post: Post
    @State private var isReplying: Bool = false
    @EnvironmentObject var forumViewModel: ForumViewModel
    @EnvironmentObject var authViewModel: AuthViewModel

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Header
            HStack {
                Image(systemName: "person.circle.fill")
                    .resizable()
                    .frame(width: 40, height: 40)
                    .foregroundColor(.blue)
                VStack(alignment: .leading) {
                    Text(post.displayName)
                        .font(.headline)
                    Text(post.timestamp, style: .date)
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
                Spacer()
            }

            // Title
            Text(post.title)
                .font(.body)
                .padding(.vertical, 4)

            // Actions
            HStack {
              Button(action: {
                  isReplying.toggle()
              }) {
                  HStack {
                      Image(systemName: "arrowshape.turn.up.left.2.fill") // Updated icon
                      Text("Reply")
                  }
              }
                .buttonStyle(BorderlessButtonStyle())
                .foregroundColor(.blue)

                Spacer()

                Text("\(post.replies.count) Replies")
                    .font(.subheadline)
                    .foregroundColor(.gray)
            }

            // Replies
            if !post.replies.isEmpty {
                Divider()
                ForEach(post.replies) { reply in
                    ReplyView(reply: reply)
                }
            }

            // Reply Input
            if isReplying {
                InlineReplyView(post: post) {
                    isReplying = false
                }
                .environmentObject(forumViewModel)
                .environmentObject(authViewModel)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color(UIColor.secondarySystemBackground))
                .shadow(color: Color.black.opacity(0.1), radius: 4, x: 0, y: 2)
        )
        .padding(.vertical, 8)
    }
}

================
File: Views/Forum/ReplyView.swift
================
//
//  ReplyView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 11/25/24.
//

import SwiftUI


struct ReplyView: View {
    var reply: Reply

    var body: some View {
        HStack(alignment: .top, spacing: 12) {
          Image(systemName: "person.circle.fill")
              .resizable()
              .frame(width: 30, height: 30)
              .foregroundColor(.orange) 

            VStack(alignment: .leading, spacing: 4) {
                Text(reply.displayName)
                    .font(.subheadline)
                    .foregroundColor(.blue)
                Text(reply.content)
                    .font(.body)
                Text(reply.timestamp, style: .time)
                    .font(.caption)
                    .foregroundColor(.gray)
            }
            Spacer()
        }
        .padding(.vertical, 8)
    }
}

================
File: Views/Home/Articles/ArithmeticOperations.md
================
# Arithmetic Operations

Performing arithmetic operations like addition, subtraction, multiplication, and division is a fundamental concept in programming.

## Example: Calculate the Sum of Two Numbers
```swift
let a = 5
let b = 10
let sum = a + b
```

================
File: Views/Home/Articles/ArrayManipulations.md
================
# Array Manipulations

Arrays are fundamental data structures used to store collections of elements. Manipulating arrays is essential for solving problems in sorting, searching, and transforming data.

---

## Find the Maximum Element

Finding the maximum element in an array is one of the simplest and most common operations.

### Problem
Write a function to find the maximum element in a given array.

### Example
Input:  
Array: `[3, 7, 2, 8, 6]`

Output:  
`8` (Maximum element)

### Swift Implementation
```swift
func findMaximum(_ arr: [Int]) -> Int? {
    guard !arr.isEmpty else { return nil }
    var max = arr[0]
    for num in arr {
        if num > max {
            max = num
        }
    }
    return max
}
```

### Explanation
1. **Check for Empty Array**: Return `nil` if the array is empty.
2. **Iterate Through Array**: Compare each element with the current maximum.
3. **Update Maximum**: Update the maximum when a larger value is found.

---

## Count Occurrences of an Element

Counting occurrences of a specific element in an array is a common task in data analysis.

### Problem
Write a function to count the number of times a target element appears in an array.

### Example
Input:  
Array: `[1, 2, 3, 2, 2, 4]`  
Target: `2`

Output:  
`3` (Occurrences of `2`)

### Swift Implementation
```swift
func countOccurrences(_ arr: [Int], target: Int) -> Int {
    return arr.filter { $0 == target }.count
}
```

### Explanation
1. **Filter Elements**: Use `.filter` to create a new array containing only the elements that match the target.
2. **Count Elements**: Return the count of the filtered array.

---

## Find Intersection of Two Arrays

The intersection of two arrays is a set of elements that appear in both arrays.

### Problem
Write a function to find the intersection of two arrays.

### Example
Input:  
Array 1: `[1, 2, 3, 4]`  
Array 2: `[3, 4, 5, 6]`

Output:  
Intersection: `[3, 4]`

### Swift Implementation
```swift
func intersection(_ a: [Int], _ b: [Int]) -> [Int] {
    let setA = Set(a)
    let setB = Set(b)
    return Array(setA.intersection(setB))
}
```

### Explanation
1. **Convert to Sets**: Use `Set` to efficiently find common elements.
2. **Find Intersection**: Use `.intersection` to find common elements between two sets.
3. **Return as Array**: Convert the result back to an array.

---

## Merge Two Sorted Arrays

Merging sorted arrays is a fundamental operation used in divide-and-conquer algorithms.

### Problem
Write a function to merge two sorted arrays into one sorted array.

### Example
Input:  
Array 1: `[1, 3, 5]`  
Array 2: `[2, 4, 6]`

Output:  
Merged Array: `[1, 2, 3, 4, 5, 6]`

### Swift Implementation
```swift
func mergeSortedArrays(_ a: [Int], _ b: [Int]) -> [Int] {
    var merged = [Int]()
    var i = 0, j = 0
    while i < a.count && j < b.count {
        if a[i] < b[j] {
            merged.append(a[i])
            i += 1
        } else {
            merged.append(b[j])
            j += 1
        }
    }
    while i < a.count {
        merged.append(a[i])
        i += 1
    }
    while j < b.count {
        merged.append(b[j])
        j += 1
    }
    return merged
}
```

### Explanation
1. **Two Pointers**: Use two pointers to traverse the arrays.
2. **Compare Elements**: Append the smaller element to the result array.
3. **Merge Remaining Elements**: Append any remaining elements from either array.

---

## Transpose a Matrix

Transposing a matrix involves flipping rows and columns.

### Problem
Write a function to transpose a given matrix.

### Example
Input:  
Matrix:  
```
[[1, 2, 3],
 [4, 5, 6]]
```

Output:  
Transposed Matrix:  
```
[[1, 4],
 [2, 5],
 [3, 6]]
```

### Swift Implementation
```swift
func transpose(_ matrix: [[Int]]) -> [[Int]] {
    guard let firstRow = matrix.first else { return [] }
    var transposed = Array(repeating: Array(repeating: 0, count: matrix.count), count: firstRow.count)
    for (i, row) in matrix.enumerated() {
        for (j, val) in row.enumerated() {
            transposed[j][i] = val
        }
    }
    return transposed
}
```

### Explanation
1. **Empty Matrix Check**: Return an empty matrix if the input is empty.
2. **Transpose Logic**: Flip rows and columns using nested loops.
3. **Result**: Return the new transposed matrix.

---

Array manipulations are a cornerstone of solving algorithmic problems. Practicing these operations will help you develop a strong foundation for tackling more complex challenges!

================
File: Views/Home/Articles/HelloWorld.md
================
# Print "Hello World"

Printing "Hello World" is often the first step in learning any programming language. This task helps you understand the basic syntax required to produce output.

## Example in Swift
```swift
func greet() {
    print("Hello World")
}

================
File: Views/Home/Articles/IntroductionToArrays.md
================
# Introduction to Arrays

Arrays are collections of elements that **store data** in a sequential order. They are one of the most fundamental data structures in programming.

## Why Use Arrays?

- **Fast access**: Access elements by their index.
- **Efficient storage**: Store multiple values in a single variable.
- **Sequential organization**: Maintain the order of elements.

## Example in Swift

```swift
// Declare an array of integers
var numbers = [1, 2, 3, 4, 5]

// Access the first element
let first = numbers[0]

// Add a new element
numbers.append(6)

================
File: Views/Home/Articles/LinkedListManipulations.md
================
# Linked List Manipulations

A linked list is a linear data structure where each element (node) points to the next. Linked lists are widely used in scenarios where dynamic memory allocation and efficient insertions/deletions are required.

---

## Remove Nth Node from End

Removing the Nth node from the end of a linked list involves identifying the node’s position and updating the links accordingly.

### Problem
Write a function to remove the Nth node from the end of a linked list.

### Example
Input:  
Linked List: `1 -> 2 -> 3 -> 4 -> 5`  
N: `2`

Output:  
Linked List: `1 -> 2 -> 3 -> 5`

### Swift Implementation
```swift
class ListNode {
    var val: Int
    var next: ListNode?
    init(_ val: Int) {
        self.val = val
        self.next = nil
    }
}

func removeNthFromEnd(_ head: ListNode?, _ n: Int) -> ListNode? {
    let dummy = ListNode(0)
    dummy.next = head
    var first: ListNode? = dummy
    var second: ListNode? = dummy
    for _ in 0..<n+1 {
        first = first?.next
    }
    while first != nil {
        first = first?.next
        second = second?.next
    }
    second?.next = second?.next?.next
    return dummy.next
}
```

### Explanation
1. **Dummy Node**: Use a dummy node to simplify edge cases, such as removing the first node.
2. **Two Pointers**: Maintain two pointers (`first` and `second`) separated by `n + 1` nodes.
3. **Traversal**: Move both pointers until `first` reaches the end. The `second` pointer will then be at the node before the target node.
4. **Remove Node**: Update the `next` pointer of `second` to skip the target node.

---

## Merge Two Sorted Linked Lists

Merging two sorted linked lists involves creating a new sorted list by selecting the smallest nodes from each input list.

### Problem
Write a function to merge two sorted linked lists.

### Example
Input:  
List 1: `1 -> 3 -> 5`  
List 2: `2 -> 4 -> 6`

Output:  
Merged List: `1 -> 2 -> 3 -> 4 -> 5 -> 6`

### Swift Implementation
```swift
func mergeTwoLists(_ list1: ListNode?, _ list2: ListNode?) -> ListNode? {
    let dummy = ListNode(0)
    var current = dummy
    var l1 = list1
    var l2 = list2

    while l1 != nil && l2 != nil {
        if l1!.val < l2!.val {
            current.next = l1
            l1 = l1?.next
        } else {
            current.next = l2
            l2 = l2?.next
        }
        current = current.next!
    }

    current.next = l1 ?? l2
    return dummy.next
}
```

### Explanation
1. **Dummy Node**: Use a dummy node to simplify the merging process.
2. **Comparison**: Compare the values of the current nodes in both lists and append the smaller one to the result.
3. **Merge Remaining Nodes**: Append any remaining nodes from one of the lists.

---

## Detect a Cycle in a Linked List

Detecting a cycle in a linked list is a classic problem in algorithmic challenges.

### Problem
Write a function to detect if a linked list contains a cycle.

### Example
Input:  
Linked List: `1 -> 2 -> 3 -> 4 -> 2 (cycle)`

Output:  
`true` (Cycle exists)

### Swift Implementation
```swift
func hasCycle(_ head: ListNode?) -> Bool {
    var slow = head
    var fast = head

    while fast != nil && fast?.next != nil {
        slow = slow?.next
        fast = fast?.next?.next
        if slow === fast {
            return true
        }
    }
    return false
}
```

### Explanation
1. **Two Pointers**: Use a slow pointer (moves 1 step at a time) and a fast pointer (moves 2 steps at a time).
2. **Cycle Detection**: If the pointers meet, a cycle exists.
3. **Termination**: If the `fast` pointer reaches the end of the list, there’s no cycle.

---

## Reverse a Linked List

Reversing a linked list involves reassigning the `next` pointers of each node to point to the previous node.

### Problem
Write a function to reverse a linked list.

### Example
Input:  
Linked List: `1 -> 2 -> 3 -> 4 -> 5`

Output:  
Reversed Linked List: `5 -> 4 -> 3 -> 2 -> 1`

### Swift Implementation
```swift
func reverseList(_ head: ListNode?) -> ListNode? {
    var prev: ListNode? = nil
    var current = head

    while current != nil {
        let next = current?.next
        current?.next = prev
        prev = current
        current = next
    }

    return prev
}
```

### Explanation
1. **Three Pointers**: Use `prev`, `current`, and `next` to manage the reversal process.
2. **Reassign Pointers**: Update the `next` pointer of each node to point to the previous node.
3. **Return Result**: Return the new head of the reversed list.

---

Linked list manipulations are crucial for solving problems in dynamic memory allocation and pointer-based operations. Practice these patterns to strengthen your algorithmic skills!

================
File: Views/Home/Articles/SearchingAndSorting.md
================
# Searching and Sorting

Searching and sorting are critical concepts in computer science, used for organizing and retrieving data efficiently. Mastering these operations is essential for writing performant and scalable applications.

---

## Binary Search

Binary search is a highly efficient algorithm for finding an element in a sorted array. It works by repeatedly dividing the search interval in half.

### Problem
Write a function that performs binary search on a sorted array.

### Example
Input:
Array: `[1, 3, 5, 7, 9]`
Target: `5`

Output:
`2` (Index of the target element)

### Swift Implementation
```swift
func binarySearch(_ arr: [Int], target: Int) -> Int? {
    var left = 0
    var right = arr.count - 1
    while left <= right {
        let mid = left + (right - left) / 2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return nil
}
```

### Explanation
1. **Initialize Pointers**: Start with pointers `left` and `right` representing the bounds of the search interval.
2. **Calculate Midpoint**: Use `(left + right) / 2` to find the middle index.
3. **Adjust Bounds**: Narrow the search interval based on comparisons with the target.
4. **Return Result**: If the target is found, return its index; otherwise, return `nil`.

---

## Bubble Sort

Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.

### Problem
Write a function to sort an array using the bubble sort algorithm.

### Example
Input:
Array: `[5, 3, 8, 4, 2]`

Output:
Array: `[2, 3, 4, 5, 8]`

### Swift Implementation
```swift
func bubbleSort(_ arr: inout [Int]) {
    let n = arr.count
    for i in 0..<n {
        for j in 0..<(n - i - 1) {
            if arr[j] > arr[j + 1] {
                arr.swapAt(j, j + 1)
            }
        }
    }
}
```

### Explanation
1. **Outer Loop**: Controls the number of passes.
2. **Inner Loop**: Compares adjacent elements and swaps them if necessary.
3. **Optimization**: After each pass, the largest unsorted element is in its correct position.

---

## Find the Second Largest Element

Finding the second largest element is a common problem in competitive programming and algorithmic challenges.

### Problem
Write a function to find the second largest element in an array.

### Example
Input:
Array: `[5, 8, 12, 7, 9]`

Output:
`9` (Second largest element)

### Swift Implementation
```swift
func secondLargest(_ arr: [Int]) -> Int? {
    var first: Int? = nil
    var second: Int? = nil
    for num in arr {
        if first == nil || num > first! {
            second = first
            first = num
        } else if (second == nil || num > second!) && num != first {
            second = num
        }
    }
    return second
}
```

### Explanation
1. **Initialization**: Use two variables `first` and `second` to track the largest and second largest elements.
2. **Update Logic**: Update `first` and `second` as you iterate through the array.
3. **Return Result**: Return `second`, which contains the second largest element.

---

## Merge Sorted Arrays

Merging sorted arrays is a fundamental operation in divide-and-conquer algorithms like merge sort.

### Problem
Write a function to merge two sorted arrays into one sorted array.

### Example
Input:
Array 1: `[1, 3, 5]`
Array 2: `[2, 4, 6]`

Output:
Merged Array: `[1, 2, 3, 4, 5, 6]`

### Swift Implementation
```swift
func mergeSortedArrays(_ a: [Int], _ b: [Int]) -> [Int] {
    var merged = [Int]()
    var i = 0, j = 0
    while i < a.count && j < b.count {
        if a[i] < b[j] {
            merged.append(a[i])
            i += 1
        } else {
            merged.append(b[j])
            j += 1
        }
    }
    while i < a.count {
        merged.append(a[i])
        i += 1
    }
    while j < b.count {
        merged.append(b[j])
        j += 1
    }
    return merged
}
```

### Explanation
1. **Pointers**: Use two pointers to track the current index of each array.
2. **Comparison**: Compare the elements at the pointers and append the smaller one to the result.
3. **Merge Remaining Elements**: Append any remaining elements from either array.

---

Searching and sorting are foundational techniques that form the basis for more advanced algorithms. Practicing these operations will significantly enhance your problem-solving skills!

================
File: Views/Home/Articles/SlidingWindow.md
================
# Sliding Window Technique

The sliding window technique is an efficient method used to solve problems involving substrings or subarrays in arrays and strings. It reduces the time complexity of brute-force solutions by using a dynamic range to process elements.

---

## Longest Substring Without Repeating Characters

Finding the longest substring without repeating characters is a common sliding window problem.

### Problem
Write a function to find the length of the longest substring without repeating characters.

### Example
Input:  
String: `"abcabcbb"`

Output:  
`3` (The substring is `"abc"`)

### Swift Implementation
```swift
func lengthOfLongestSubstring(_ s: String) -> Int {
    var charIndexMap = [Character: Int]()
    var maxLength = 0
    var start = 0

    for (i, char) in s.enumerated() {
        if let index = charIndexMap[char], index >= start {
            start = index + 1
        }
        charIndexMap[char] = i
        maxLength = max(maxLength, i - start + 1)
    }

    return maxLength
}
```

### Explanation
1. **Tracking Characters**: Use a dictionary `charIndexMap` to store the most recent index of each character.
2. **Sliding the Window**: Adjust the `start` pointer whenever a repeated character is found within the current window.
3. **Update Maximum Length**: Calculate the maximum length of the substring in each iteration.

---

## Maximum Sum Subarray of Fixed Size

Finding the maximum sum of a subarray of a fixed size `k` is another sliding window problem.

### Problem
Write a function to find the maximum sum of a subarray of size `k`.

### Example
Input:  
Array: `[2, 1, 5, 1, 3, 2]`  
`k = 3`

Output:  
`9` (The subarray is `[5, 1, 3]`)

### Swift Implementation
```swift
func maxSumSubarray(_ arr: [Int], k: Int) -> Int {
    guard arr.count >= k else { return 0 }

    var maxSum = 0
    var windowSum = 0

    for i in 0..<k {
        windowSum += arr[i]
    }
    maxSum = windowSum

    for i in k..<arr.count {
        windowSum += arr[i] - arr[i - k]
        maxSum = max(maxSum, windowSum)
    }

    return maxSum
}
```

### Explanation
1. **Initialize Window Sum**: Compute the sum of the first `k` elements.
2. **Slide the Window**: Add the next element and subtract the first element of the previous window.
3. **Update Maximum**: Track the maximum sum encountered.

---

## Minimum Window Substring

Finding the smallest substring containing all characters of another string is a more advanced sliding window problem.

### Problem
Write a function to find the minimum window substring containing all characters of a target string.

### Example
Input:  
String: `"ADOBECODEBANC"`  
Target: `"ABC"`

Output:  
`"BANC"`

### Swift Implementation
```swift
func minWindow(_ s: String, _ t: String) -> String {
    var dictT = [Character: Int]()
    for char in t {
        dictT[char, default: 0] += 1
    }

    var left = 0
    var right = 0
    var formed = 0
    let required = dictT.count
    var windowCounts = [Character: Int]()
    var ans: (length: Int, left: Int, right: Int) = (Int.max, 0, 0)

    while right < s.count {
        let char = s[s.index(s.startIndex, offsetBy: right)]
        windowCounts[char, default: 0] += 1

        if let count = dictT[char], windowCounts[char] == count {
            formed += 1
        }

        while left <= right && formed == required {
            if right - left + 1 < ans.length {
                ans = (right - left + 1, left, right)
            }

            let leftChar = s[s.index(s.startIndex, offsetBy: left)]
            windowCounts[leftChar]! -= 1
            if let count = dictT[leftChar], windowCounts[leftChar]! < count {
                formed -= 1
            }
            left += 1
        }

        right += 1
    }

    return ans.length == Int.max ? "" : String(s[s.index(s.startIndex, offsetBy: ans.left)...s.index(s.startIndex, offsetBy: ans.right)])
}
```

### Explanation
1. **Tracking Frequencies**: Use a dictionary to track the frequency of characters in the target string.
2. **Expand and Contract**: Expand the `right` pointer to include characters and contract the `left` pointer to minimize the window size while maintaining validity.
3. **Store Result**: Update the result whenever a valid window is found.

---

The sliding window technique optimizes problems by reducing redundant computations, making it a must-know approach for competitive programming and coding interviews!

================
File: Views/Home/Articles/StringManipulations.md
================
# String Manipulations

Strings are sequences of characters and form one of the most commonly used data types in programming. Manipulating strings is essential for solving real-world problems such as data parsing, validation, and text processing.

In this guide, we’ll cover key operations such as reversing strings, trimming whitespace, and checking specific indexes.

---

## Reverse a String

Reversing a string involves rearranging its characters in the opposite order. This operation is useful in scenarios like string-based algorithms or preparing text for display.

### Problem
Write a function that reverses the characters of a given string.

### Example
Input:  
`"hello"`

Output:  
`"olleh"`

### Swift Implementation
Here’s how you can reverse a string in Swift:
```swift
func reverseString(_ s: String) -> String {
    var reversed = ""
    for char in s {
        reversed = String(char) + reversed
    }
    return reversed
}
```

### Explanation
1. **Initialization**: Start with an empty string `reversed`.
2. **Iteration**: For each character in the input string `s`, prepend it to the `reversed` string. This ensures characters are added in reverse order.
3. **Return Result**: Once all characters are processed, return the reversed string.

### Optimization Tip
For better performance with large strings, use Swift’s `reversed()` method:
```swift
func reverseString(_ s: String) -> String {
    return String(s.reversed())
}
```

---

## Trim Whitespace from a String

Trimming removes unnecessary whitespace from the beginning and end of a string. This is helpful in user input validation or formatting.

### Problem
Write a function that trims leading and trailing whitespace from a string.

### Example
Input:  
`"   Swift is fun!   "`

Output:  
`"Swift is fun!"`

### Swift Implementation
Use Swift’s `trimmingCharacters(in:)` method to efficiently remove whitespace:
```swift
func trimWhitespace(_ s: String) -> String {
    return s.trimmingCharacters(in: .whitespacesAndNewlines)
}
```

### Explanation
1. **Method**: The `.trimmingCharacters(in:)` method removes characters from the specified character set.
2. **Parameter**: `.whitespacesAndNewlines` includes spaces, tabs, and newlines.

---

## Check Characters at Specific Indexes

Accessing characters at specific indexes is a common operation, whether you're validating input, comparing strings, or implementing algorithms.

### Problem
Write a function to return the character at a given index in a string.

### Example
Input:  
String: `"Hello"`  
Index: `1`

Output:  
`"e"`

### Swift Implementation
Use Swift’s `index(_:offsetBy:)` method to safely access characters:
```swift
func characterAt(_ s: String, index: Int) -> Character? {
    guard index >= 0 && index < s.count else {
        return nil // Index out of bounds
    }
    return s[s.index(s.startIndex, offsetBy: index)]
}
```

### Explanation
1. **Bounds Checking**: Use a `guard` statement to ensure the index is within valid bounds.
2. **Index Calculation**: Use `s.index(s.startIndex, offsetBy: index)` to calculate the position of the character in `s`.

### Example Usage
```swift
let word = "Hello"
if let char = characterAt(word, index: 1) {
    print("Character at index 1: \(char)") // Output: "e"
}
```

---

## Additional String Operations

### Palindrome Check
Check if a string reads the same backward and forward:
```swift
func isPalindrome(_ s: String) -> Bool {
    let cleaned = s.lowercased().filter { $0.isLetter }
    return cleaned == String(cleaned.reversed())
}
```

### Count Occurrences of a Character
Count how many times a specific character appears in a string:
```swift
func countOccurrences(of target: Character, in s: String) -> Int {
    return s.filter { $0 == target }.count
}
```

### Replace Substring
Replace all occurrences of a substring with another:
```swift
func replaceSubstring(_ s: String, target: String, replacement: String) -> String {
    return s.replacingOccurrences(of: target, with: replacement)
}
```

### Example
Input:  
String: `"Swift is fun!"`  
Target: `"fun"`  
Replacement: `"awesome"`

Output:  
`"Swift is awesome!"`

---

String manipulation is a foundational skill for solving complex problems. Mastering these operations will significantly improve your ability to write clean and efficient code!

================
File: Views/Home/Articles/UnderstandingRecursion.md
================
# Understanding Recursion

Recursion is a method where the solution to a problem depends on solving smaller instances of the same problem.

## How It Works

In recursion, a function calls itself with a simpler or smaller input. Each recursive call brings the problem closer to a base case, which stops the recursion.

## Example: Factorial in Swift

```swift
func factorial(_ n: Int) -> Int {
    if n <= 1 {
        return 1 // Base case
    }
    return n * factorial(n - 1) // Recursive case
}

```

## Factorial Calculation:

factorial(3) → 3 * factorial(2)
factorial(2) → 2 * factorial(1)
factorial(1) → 1 (base case)


## When to Use Recursion

Recursion is useful when:

Problems can be broken down into smaller, similar sub-problems.
Iterative solutions are less intuitive or require additional data structures.

================
File: Views/Home/ArticleDetailView.swift
================
//
//  ArticleDetailView.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 9/24/24.
//

import SwiftUI
import MarkdownUI

struct ArticleDetailView: View {
    let articleTitle: String

    var body: some View {
        ScrollView {
            if let content = loadMarkdown(for: articleTitle) {
                Markdown(content)
                    .padding()
            } else {
                Text("Content not available.")
                    .padding()
            }
        }
        .navigationTitle(articleTitle)
    }

  func loadMarkdown(for title: String) -> String? {
      // Convert the article title to the corresponding file name
      let fileName = title.replacingOccurrences(of: " ", with: "") + ".md"

      guard let fileURL = Bundle.main.url(forResource: fileName, withExtension: nil) else {
          print("DEBUG: File not found for \(fileName)")
          return nil
      }
      print("DEBUG: File found at \(fileURL.path)")
      return try? String(contentsOf: fileURL, encoding: .utf8)
  }
  

}

#Preview {
    ProblemsView()
        .environmentObject(UserStatsViewModel())
}

================
File: Views/Home/HomeView.swift
================
import SwiftUI

struct HomeView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.colorScheme) var colorScheme
    @State private var showingSignIn = false
    @State private var path = NavigationPath()
    
    var body: some View {
        NavigationStack(path: $path) {
            ScrollView {
                VStack(spacing: 20) {
                    // Welcome Header
                    if authViewModel.isSignedIn {
                        ProfileHeaderView()
                    } else {
                        SignInPromptView(showingSignIn: $showingSignIn)
                    }
                    
                    // AutoScroller Carousel
                    AutoScroller(path: $path)
                    
                    // Additional Content
                    VStack(spacing: 16) {
                        Text("Your Progress")
                            .font(.headline)
                            .foregroundColor(.primary)
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .padding(.horizontal)
                        
                        HStack(spacing: 16) {
                            ProgressCardView(
                                title: "Problems Solved",
                                value: "42",
                                iconName: "checkmark.seal.fill",
                                iconColor: .green
                            )
                            ProgressCardView(
                                title: "Lessons Completed",
                                value: "15",
                                iconName: "book.fill",
                                iconColor: .orange
                            )
                            ProgressCardView(
                                title: "Resume Tips Read",
                                value: "5",
                                iconName: "briefcase.fill",
                                iconColor: .purple
                            )
                        }
                        .padding(.horizontal)
                    }
                }
                .sheet(isPresented: $showingSignIn) {
                    SignInView()
                        .environmentObject(authViewModel)
                }
              
            }
            .navigationDestination(for: TabDestination.self) { destination in
                switch destination {
                case .problems:
                    ProblemsView()
                case .learning:
                    LearningView()
                case .resumeTips:
                    ResumeView()
                }
            }
            .background(
                LinearGradient(
                    gradient: Gradient(colors: [Color.blue.opacity(0.2), Color.purple.opacity(0.2)]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
            )
        }
    }
}

// Profile Header View
struct ProfileHeaderView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
      Spacer()
        HStack(spacing: 16) {
            Image(systemName: "person.fill")
                .resizable()
                .frame(width: 50, height: 50)
                .foregroundStyle(.blue)
          
            VStack(alignment: .leading, spacing: 4) {
                Text("Welcome, \(authViewModel.user?.displayName ?? "No Name")!")
                .font(.title2.bold())
                    .foregroundColor(.primary)
                Text("Ready to continue learning?")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            Spacer()
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.cardBackground)
                .shadow(
                    color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.1),
                    radius: 8, x: 0, y: 4
                )
        )
        .padding(.horizontal)
    }
}

// Progress Card View
struct ProgressCardView: View {
    var title: String
    var value: String
    var iconName: String
    var iconColor: Color
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: iconName)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(height: 30)
                .foregroundColor(.white)
                .padding()
                .background(iconColor)
                .clipShape(Circle())

            Text(value)
                .font(.title2.bold())
                .foregroundColor(.primary)

            Text(title)
                .font(.caption)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.cardBackground)
                .shadow(
                    color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.1),
                    radius: 8, x: 0, y: 4
                )
        )
    }
}

#Preview {
    ContentView()
        .environmentObject(AuthViewModel.shared)
        .environmentObject(UserStatsViewModel())
        .environmentObject(ProblemsData.shared)
        .environmentObject(ForumViewModel())
}

================
File: Views/Home/LearningView.swift
================
//
//  LearningView.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 9/24/24.
//

import SwiftUICore
import SwiftUI

struct LearningView: View {
    let articles = ["Hello World, Introduction To Arrays", "Understanding Recursion", "Arithmetic Operations", "String Manipulations", "Array Manipulations", "Linked List Manipulations", "Search And Sorting", "Sliding Window"]

    var body: some View {
        List(articles, id: \.self) { article in
            NavigationLink(destination: ArticleDetailView(articleTitle: article)) {
                Text(article)
                    .font(.headline)
            }
        }
        .navigationTitle("Learning")
    }
}

================
File: Views/Home/ResumeView.swift
================
//
//  ResumeView.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 9/24/24.
//

import SwiftUICore
import SwiftUI

struct ResumeView: View {
    let articles = ["Introduction to Arrays", "Understanding Recursion"]

    var body: some View {
        List(articles, id: \.self) { article in
            NavigationLink(destination: ArticleDetailView(articleTitle: article)) {
                Text(article)
                    .font(.headline)
            }
        }
        .navigationTitle("Resume Tips")
    }
}

#Preview {
  ResumeView()
}

================
File: Views/Problems/ProblemDetailView.swift
================
import SwiftUI

struct ProblemDetailView: View {
    let problem: Problem
    @State private var availableBlocks: [String]
    @State private var arrangedBlocks: [String]
    @State private var isProblemSolved = false
    @EnvironmentObject var userStatsViewModel: UserStatsViewModel
    @State private var showArticle = false

    // Add this line
    @State private var searchText = ""

    // MARK: - Initialization
    init(problem: Problem) {
        self.problem = problem
        _availableBlocks = State(initialValue: problem.availableBlocks)
        _arrangedBlocks = State(initialValue: Array(repeating: "", count: problem.correctSolution.count))
    }

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 20) {
                if isProblemSolved {
                    Text("🎉 Congratulations! You've solved this problem.")
                        .font(.headline)
                        .foregroundColor(.green)
                        .padding()
                }

                ProblemHeaderView(problem: problem)
              
                AvailableBlocksSection(availableBlocks: $availableBlocks)

                VStack(alignment: .leading, spacing: 10) {
                    Text("Your Solution")
                        .font(.headline)

                    DragGestureList(
                        arrangedBlocks: $arrangedBlocks,
                        availableBlocks: $availableBlocks,
                        problem: problem,
                        isProblemSolved: $isProblemSolved,
                        userStatsViewModel: userStatsViewModel
                    )
                }
                .padding()

                SolutionButtonsSection(
                    checkSolution: checkSolution,
                    resetSolution: resetSolution,
                    openArticle: {
                        showArticle = true
                    }
                )
            }
            .padding()
        }
        .onAppear {
            if userStatsViewModel.solvedProblemIDs.contains(problem.id.uuidString) {
                isProblemSolved = true
            }
        }
        .sheet(isPresented: $showArticle) {
            ArticleDetailView(articleTitle: problem.articleTitle)
        }
        .alert(isPresented: $showingAlert) {
            Alert(
                title: Text("Result"),
                message: Text(alertMessage),
                dismissButton: .default(Text("OK"))
            )
        }
    }


    // MARK: - Additional States
    @State private var showingAlert: Bool = false
    @State private var alertMessage: String = ""

    // MARK: - Helper Functions
    private func checkSolution() {
        var allCorrect = true
        for index in 0..<arrangedBlocks.count {
            if arrangedBlocks[index] != problem.correctSolution[index] {
                allCorrect = false
                break
            }
        }

        if allCorrect {
            isProblemSolved = true
            userStatsViewModel.problemSolved(problemID: problem.id)
            alertMessage = "🎉 Well done! You've solved the problem."
        } else {
            alertMessage = "❌ Some blocks are incorrect. Please try again."
        }

        showingAlert = true
    }

    private func resetSolution() {
        arrangedBlocks = Array(repeating: "", count: problem.correctSolution.count)
        availableBlocks = problem.availableBlocks
        isProblemSolved = false
    }
}


struct AvailableBlocksSection: View {
    @Binding var availableBlocks: [String]
    @State private var expandedCategories: Set<String> = ["Initialization", "Control Flow", "Functions", "Others"]

    var body: some View {
        VStack(alignment: .leading, spacing: 10) {
            Text("Available Blocks")
                .font(.headline)

            // Categorization Logic
            ForEach(["Initialization", "Control Flow", "Functions", "Others"], id: \.self) { category in
                VStack(alignment: .leading) {
                    CategoryHeader(category: category, isExpanded: expandedCategories.contains(category)) {
                        toggleCategory(category)
                    }

                    if expandedCategories.contains(category) {
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 10) {
                                ForEach(filteredAvailableBlocks(for: category), id: \.self) { block in
                                    CodeBlockView(code: block, backgroundColor: Color.blue.opacity(0.1))
                                        .onDrag {
                                            NSItemProvider(object: block as NSString)
                                        }
                                }
                            }
                        }
                        .padding(.bottom, 10)
                    }
                }
                .padding(.horizontal)
            }
        }
        .padding()
    }

    private func toggleCategory(_ category: String) {
        if expandedCategories.contains(category) {
            expandedCategories.remove(category)
        } else {
            expandedCategories.insert(category)
        }
    }

    private func categorizeBlock(_ block: String) -> String {
        // Basic categorization logic
        if block.contains("func") || block.contains("let") || block.contains("var") {
            return "Initialization"
        } else if block.contains("if") || block.contains("for") || block.contains("while") || block.contains("return") {
            return "Control Flow"
        } else {
            return "Functions"
        }
    }

    private func filteredAvailableBlocks(for category: String) -> [String] {
        return availableBlocks.filter { categorizeBlock($0) == category }
    }
}

struct CategoryHeader: View {
    let category: String
    let isExpanded: Bool
    let toggle: () -> Void
    
    var body: some View {
        HStack {
            Text(category)
                .font(.subheadline)
                .bold()
            Spacer()
            Button(action: toggle) {
                Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                    .foregroundColor(.blue)
            }
        }
        .padding(.vertical, 5)
    }
}

struct DragGestureList: View {
    @Binding var arrangedBlocks: [String]
    @Binding var availableBlocks: [String]
    let problem: Problem
    @Binding var isProblemSolved: Bool
    @ObservedObject var userStatsViewModel: UserStatsViewModel
    
    var body: some View {
        VStack {
            ForEach(arrangedBlocks.indices, id: \.self) { index in
                if arrangedBlocks[index].isEmpty {
                    DropZoneView()
                        .onDrop(of: [.plainText], isTargeted: nil) { providers in
                            handleDrop(providers: providers, at: index)
                        }
                        .padding(.vertical, 4)
                } else {
                    CodeBlockView(code: arrangedBlocks[index], backgroundColor: Color.blue.opacity(0.2))
                        .onDrag {
                            return NSItemProvider(object: arrangedBlocks[index] as NSString)
                        }
                        .onDrop(of: [.plainText], isTargeted: nil) { providers in
                            handleDrop(providers: providers, at: index)
                        }
                        .padding(.vertical, 4)
                }
            }
        }
    }
    
    private func handleDrop(providers: [NSItemProvider], at index: Int) -> Bool {
        guard let provider = providers.first else { return false }
        provider.loadObject(ofClass: String.self) { (object, error) in
            DispatchQueue.main.async {
                if let block = object as? String {
                    // Remove block from availableBlocks
                    if let availableIndex = availableBlocks.firstIndex(of: block) {
                        availableBlocks.remove(at: availableIndex)
                    }
                    // Replace any existing block in the drop zone back to availableBlocks
                    if !arrangedBlocks[index].isEmpty {
                        availableBlocks.append(arrangedBlocks[index])
                    }
                    // Assign the new block
                    arrangedBlocks[index] = block
                }
            }
        }
        return true
    }
}

struct DropZoneView: View {
    var body: some View {
        RoundedRectangle(cornerRadius: 10)
            .stroke(Color.gray.opacity(0.5), lineWidth: 2)
            .frame(height: 50)
            .overlay(
                Text("Drop Here")
                    .foregroundColor(.gray)
            )
            .background(Color.gray.opacity(0.1))
            .cornerRadius(10)
    }
}

struct SolutionButtonsSection: View {
    let checkSolution: () -> Void
    let resetSolution: () -> Void
    let openArticle: () -> Void
    
    var body: some View {
        HStack(spacing: 20) {
            Button(action: checkSolution) {
                Text("Check Solution")
                    .font(.headline)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.accentColor)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            
            Button(action: resetSolution) {
                Text("Reset")
                    .font(.headline)
                    .padding()
                    .frame(maxWidth: .infinity)
                    .background(Color.red)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
        }
        .padding(.horizontal)
        
        Button(action: openArticle) {
            Text("Read Article 📖")
                .font(.headline)
                .padding()
                .frame(maxWidth: .infinity)
                .background(Color.green)
                .foregroundColor(.white)
                .cornerRadius(10)
        }
        .padding(.horizontal)
    }
}

struct DragGestureList_Previews: PreviewProvider {
    static var previews: some View {
        DragGestureList(
            arrangedBlocks: .constant(["func example() {", ""]),
            availableBlocks: .constant(["print(\"Sample\")", "}"]),
            problem: Problem(
                id: UUID(),
                title: "Sample Problem",
                description: "Arrange the code blocks to complete the function.",
                difficulty: "Easy",
                articleTitle: "Sample Problem Article"
,
                availableBlocks: [
                    "func example() {",
                    "print(\"Sample\")",
                    "}"
                ],
                correctSolution: [
                    "func example() {",
                    "print(\"Sample\")",
                    "}"
                ]
            ),
            isProblemSolved: .constant(false),
            userStatsViewModel: UserStatsViewModel()
        )
        .previewLayout(.sizeThatFits)
    }
}

struct DropZoneView_Previews: PreviewProvider {
    static var previews: some View {
        DropZoneView()
            .previewLayout(.sizeThatFits)
    }
}

================
File: Views/Problems/ProblemsView.swift
================
//
//  ProblemsView.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 9/24/24.
//

import SwiftUI

struct ProblemsView: View {
    @EnvironmentObject var userStatsViewModel: UserStatsViewModel
    @ObservedObject var problemsData = ProblemsData.shared

    var body: some View {
        NavigationView {
            List(problemsData.problems) { problem in
                NavigationLink(destination: ProblemDetailView(problem: problem)) {
                  VStack(alignment: .leading) {
                    HStack {
                      Text(problem.title)
                        .font(.headline)
                      if userStatsViewModel.solvedProblemIDs.contains(problem.id.uuidString) {
                        Image(systemName: "checkmark.circle.fill")
                          .foregroundColor(.green)
                      }
                    }
                    HStack {
                      Text("Difficulty:")
                        .font(.caption)
                        .padding(0)
                      
                      Text(problem.difficulty)
                      .font(.caption)
                      .padding(4)
                      .background(difficultyColor(for: problem.difficulty))
                      .foregroundColor(.white)
                      .cornerRadius(5)
                  }
                    }
                }
            }
            .navigationTitle("Problems")
        }
        .applyBackgroundGradient()
    }
}

func difficultyColor(for difficulty: String) -> Color {
    switch difficulty.lowercased() {
    case "easy":
        return .green
    case "medium":
        return .orange
    case "hard":
        return .red
    default:
        return .gray
    }
}

#Preview {
    ProblemsView()
        .environmentObject(UserStatsViewModel())
}

================
File: Views/Search/SearchView.swift
================
//
//  SearchView.swift
//  CodeBuilder
//
//  Created by aaron perkel on 9/25/24.
//

import SwiftUI

struct SearchView: View {
  @State private var searchText = ""
  var body: some View {
    NavigationStack {
      SearchBar(text: $searchText)
      List {
        Section {
          Text("Search View")
          Text("This will include types of problems")
          Text("Imagine the spotify search page")
          Text("Blocky and pictures and stuff")
          Text("Top 150 Interview Questions")
        }
      }
      .navigationTitle("Search")
      .navigationBarTitleDisplayMode(.large)
    }
  }
}

#Preview {
  SearchView()
}

================
File: Views/Settings/AccountView.swift
================
//
//  AccountView.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 9/24/24.
//

import SwiftUI

struct AccountView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @EnvironmentObject var userStatsViewModel: UserStatsViewModel // Ensure this is present

    var body: some View {
        NavigationStack {
            VStack(spacing: 12) {
                Image(systemName: "person.fill")
                    .resizable()
                    .frame(width: 70, height: 70)
                    .foregroundStyle(.blue)
                    .padding(.top, 25)

                VStack(spacing: 2) {
                    Text(authViewModel.user?.displayName ?? "No Name")
                        .font(.system(size: 28, weight: .semibold))
                    Text(verbatim: authViewModel.user?.email ?? "No Email")
                        .font(.system(size: 18))
                        .foregroundColor(.gray)
                    
                    // Display Problems Solved
                    Text("Problems Solved: \(userStatsViewModel.problemsSolved)")
                        .font(.system(size: 18))
                        .foregroundColor(.blue)
                        .padding(.top, 5)
                }

                List {
                    Section {
                        NavigationLink(destination: Text("Personal Information")) {
                            HStack {
                                Image(systemName: "person.text.rectangle.fill")
                                    .foregroundColor(.blue)
                                Text("Personal Information")
                            }
                        }

                        NavigationLink(destination: Text("Subscription Info")) {
                            HStack {
                                Image(systemName: "plus.arrow.trianglehead.clockwise")
                                    .foregroundColor(.blue)
                                Text("Subscriptions")
                            }
                        }
                    }

                    Section {
                        Button(action: {
                            authViewModel.signOut()
                        }) {
                            Text("Sign Out")
                                .frame(maxWidth: .infinity)
                                .foregroundColor(.red)
                        }
                    }
                }
                .listStyle(InsetGroupedListStyle())
            }
            .navigationTitle("CodeBuilder Account")
            .navigationBarTitleDisplayMode(.inline)
        }
    }
}

#Preview {
    AccountView()
        .environmentObject(AuthViewModel.shared) // Use the shared singleton instance
        .environmentObject(UserStatsViewModel()) // Provide UserStatsViewModel
}

================
File: Views/Settings/AppDelegate.swift
================
//
//  AppDelegate.swift
//  CodeBuilder
//
//  Created by Miro Gohacki on 11/17/24.
//

import UIKit
import Firebase

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(_ application: UIApplication,
                     didFinishLaunchingWithOptions launchOptions:
                        [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {
        FirebaseApp.configure()
        print("✅ Firebase configured successfully in AppDelegate.")
        return true
    }
}

================
File: Views/Settings/SettingsView.swift
================
// SettingsView.swift
// CodeBuilder
// Created by aaron perkel on 9/26/24.

import SwiftUI

struct SettingsView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.colorScheme) var colorScheme
    @State private var showingSignIn = false

    // Menu items for settings
    let settingsItems: [MenuItem] = [
        MenuItem(
            title: "General",
            subtitle: "Customize app settings",
            iconName: "gearshape.fill",
            color: .blue,
            destination: AnyView(Text("General Settings"))
        ),
        MenuItem(
            title: "Notifications",
            subtitle: "Manage notification preferences",
            iconName: "bell.fill",
            color: .red,
            destination: AnyView(Text("Notification Settings"))
        ),
        MenuItem(
            title: "Widgets",
            subtitle: "Configure your widgets",
            iconName: "square.grid.2x2.fill",
            color: .orange,
            destination: AnyView(Text("Widget Settings"))
        )
    ]

    var body: some View {
        NavigationStack {
            VStack(spacing: 20) {
                // Profile Card
                if authViewModel.isSignedIn {
                    ProfileCardView()
                } else {
                    SignInPromptView(showingSignIn: $showingSignIn)
                }

                // Settings Options
                VStack(spacing: 16) {
                    ForEach(settingsItems, id: \.title) { item in
                        SettingsOptionView(
                            title: item.title,
                            subtitle: item.subtitle ?? "",
                            iconName: item.iconName,
                            iconColor: item.color,
                            destination: item.destination
                        )
                    }
                }
                .padding(.horizontal)
                .padding(.top, 10)

                Spacer()
            }
            .navigationTitle("Settings")
            .navigationBarTitleDisplayMode(.large)
            .sheet(isPresented: $showingSignIn) {
                SignInView()
                    .environmentObject(authViewModel)
            }
            .applyBackgroundGradient()
        }
    }
}

struct ProfileCardView: View {
    @EnvironmentObject var authViewModel: AuthViewModel
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        NavigationLink(destination: AccountView()) {
            HStack(spacing: 16) {
                Image(systemName: "person.fill")
                    .resizable()
                    .frame(width: 50, height: 50)
                    .foregroundStyle(.blue)

                // User Info
                VStack(alignment: .leading, spacing: 4) {
                    Text(authViewModel.user?.displayName ?? "No Name")
                        .font(.title2.bold())
                        .foregroundColor(.primary)
                    Text("Account, CodeBuilder+, and more")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                Spacer()
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color(UIColor.secondarySystemBackground))
                    .shadow(
                        color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.1),
                        radius: 8, x: 0, y: 4
                    )
            )
            .padding(.horizontal)
        }
    }
}

struct SignInPromptView: View {
    @Binding var showingSignIn: Bool
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        Button(action: {
            showingSignIn = true
        }) {
            HStack(spacing: 16) {
                // Sign-In Icon
                Image(systemName: "person.badge.plus.fill")
                    .resizable()
                    .frame(width: 60, height: 60)
                    .foregroundColor(.green)

                // Sign-In Info
                VStack(alignment: .leading, spacing: 4) {
                    Text("Sign In")
                        .font(.title2.bold())
                        .foregroundColor(.primary)
                    Text("Access your account and more")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                Spacer()
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color(UIColor.secondarySystemBackground))
                    .shadow(
                        color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.1),
                        radius: 8, x: 0, y: 4
                    )
            )
            .padding(.horizontal)
        }
    }
}

struct SettingsOptionView: View {
    var title: String
    var subtitle: String
    var iconName: String
    var iconColor: Color
    var destination: AnyView
    @Environment(\.colorScheme) var colorScheme

    var body: some View {
        NavigationLink(destination: destination) {
            HStack(spacing: 16) {
                // Icon
                Image(systemName: iconName)
                    .font(.system(size: 24))
                    .foregroundColor(.white)
                    .frame(width: 60, height: 60)
                    .background(iconColor)
                    .clipShape(RoundedRectangle(cornerRadius: 12))

                // Text
                VStack(alignment: .leading, spacing: 4) {
                    Text(title)
                        .font(.headline)
                        .foregroundColor(.primary)
                    Text(subtitle)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }
                Spacer()
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color(UIColor.secondarySystemBackground))
                    .shadow(
                        color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.1),
                        radius: 8, x: 0, y: 4
                    )
            )
        }
    }
}

#Preview {
    SettingsView()
        .environmentObject(AuthViewModel.shared)
        .environmentObject(UserStatsViewModel())
}

================
File: CodeBuilderApp.swift
================
// CodeBuilderApp.swift
import SwiftUI
import Firebase

@main
struct CodeBuilderApp: App {
    // Integrate AppDelegate
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    @StateObject var authViewModel = AuthViewModel.shared
    @StateObject var userStatsViewModel = UserStatsViewModel()
    @StateObject var problemsData = ProblemsData.shared
    @StateObject var forumViewModel = ForumViewModel()


    var body: some Scene {
      WindowGroup {
        SplashScreenView()
            .environmentObject(authViewModel)
            .environmentObject(userStatsViewModel)
            .environmentObject(problemsData)
            .environmentObject(forumViewModel)
        
        }
      }
  
  func listAllFilesInBundle() {
      guard let resourcePath = Bundle.main.resourcePath else {
          print("Unable to find resource path")
          return
      }
      let fileManager = FileManager.default
      do {
          let allFiles = try fileManager.subpathsOfDirectory(atPath: resourcePath)
          print("All files in bundle:")
          for file in allFiles {
              print(file)
          }
      } catch {
          print("Error reading bundle contents: \(error)")
      }
  }
}

#Preview {
  SplashScreenView()
        .environmentObject(AuthViewModel.shared)
        .environmentObject(UserStatsViewModel())
        .environmentObject(ProblemsData.shared)
        .environmentObject(ForumViewModel())
}

================
File: ContentView.swift
================
// ContentView.swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        TabView {
            HomeView()
              .tabItem {
                  Label("Home", systemImage: "house.fill")
              }
            ProblemsView()
              .tabItem {
                  Label("Problems", systemImage: "list.number")
              }
            DailyChallengeView()
              .tabItem {
                  Label("Daily Challenge", systemImage: "star.fill")
              }
            ForumView()
              .tabItem {
                Label("Forum", systemImage: "paperplane.fill")
            }
            SettingsView()
              .tabItem {
                  Label("Settings", systemImage: "gearshape.fill")
              }
        }
    }
}

#Preview {
    ContentView()
        .environmentObject(AuthViewModel.shared)
        .environmentObject(UserStatsViewModel())
        .environmentObject(ProblemsData.shared)
        .environmentObject(ForumViewModel())
}
